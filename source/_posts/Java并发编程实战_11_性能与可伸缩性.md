---
title: 11 | 性能与可伸缩性
date: 2020-01-20 00:59:58
tags: [并发]
categories :
- 学习笔记
- Java
- Java并发编程实战
---

<center> <h4><font color = "#36648B">✎</br>Amdahl定律</center>

```
加速比 <= 1 / (F + (1-F)/N )
加速比/CPU的数量=CPU的利用率
```
F为串行部分占的比重，N为CPU数量。
当N趋于无穷大时，加速比趋近于**1/F**。

某个线程中的同步可能会影响其他线程的性能。因为同步会增加共享内存总线上的通信量，总线的带宽是有限的，并且所有的处理器都将共享这条总线。

<center> <h4><font color = "#36648B">✎✎</br>竞争</center>

**JVM对“竞争”的实现**
- 如果等待时间较短，则适合采用自旋等待方式。
- 如果等待时间较长，则适合采用线程挂起方式。
> 有些JVM将根据对历史等待时间的分析数据在这两者之间进行选择，但是大多数JVM在等待锁时都只是将线程挂起。

当线程无法获取某个锁或者由于在某个条件等待或在I/O操作上阻塞时，需要被挂起，在这个过程中将包含两次额外的上下文切换，以及所有必要的操作系统操作和缓存操作：被阻塞的线程在其执行时间片还未用完之前就被交换出去，而在随后当要获取的锁或者其他资源可用时，又再次被切换回来。

<center> <h4><font color = "#36648B">✎✎✎</br>锁分段</center>
在ConcurrentHashMap的实现中使用了一个包含16个锁的数组，每个锁保护所有散列桶的1/16，其中第N个散列桶由第（N mod 16）个锁来保护。

**ConcurrentHashMap对size()的实现**
ConcurrentHashMap中的size将对每个分段进行枚举并将每个分段中的元素数量相加，而不是维护一个全局计数。为了避免枚举每个元素，ConcurrentHashMap为每个分段都维护了一个独立的计数，并通过每个分段的锁来维护这个值。

<center> <h4><font color = "#36648B">✎✎✎✎</br>Java对象分配</center>

Java的分配操作比C语言的`malloc`调用更快。
对象分配操作的开销比同步的开销更低。

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           