---
title: 04 | 算法
date: 2019-10-17 00:33:49
categories :
- 学习笔记
- JVM
- 网课_JVM
---

#### <center><font color = "#36648B">✎</font><br/><font color = "#36648B">复制算法</font></center>
**1、使用场景**
年轻代中使用的是Minor GC，这种GC算法采用的是**复制算法（Copying）**。

**2、原理**
对象在Eden（包括一个Survivor区域，这里假设是from区域）出生，在经过一次MinorGC后，如果对象还存活并且能够被另外一块Survivor区域所容纳（上面已经假设为from区域，这里应为to区域，即to区域有足够的内存空间来存储Eden和from区域中存活的对象），则使用复制算法将这些仍然还存活的对象复制到另外一块Survivor区域（即to区域）中，然后清理所使用过的Eden以及Survivor区域（即from区域），并且将这些对象的年龄设置为1，此时from区与to区角色交换。以后对象在Survivor区每熬过一次MinorGC，就将对象的年龄+1，当对象的年龄达到某个值时（默认是15岁，通过`-XX:MaxTenuringThreshold`来设定参数），这些对象就会成为老年代。
当to区被填满时，则所有对象都会移动到老年区。
> 一些大对象会直接被分配在永久区。

**3、优点**
- 不会产生内存碎片

**4、缺点**
- 浪费“to区域”的空间。
- 当对象存活率高时，复制的时间会比较长。

#### <center><font color = "#36648B">✎✎</font><br/><font color = "#36648B">标记清除</font></center>
**1、使用场景**
Full GC算法是由**标记清除算法（Mark-Sweep）**实现或是**标记清除/整理算法**混合实现。

**2、原理**
- 标记：从根集合开始扫描，对存活的对象进行标记。（第一次扫描）
- 清除：扫描整个内存空间，回收未被标记的对象。（第二次扫描）
> 为什么要两次扫描？不能第一遍扫描直接清除吗？

**3、优点**
不需要额外空间。

**4、缺点**
- 两次扫描，耗时严重。
- 会产生内存碎片。

#### <center><font color = "#36648B">✎✎✎</font><br/><font color = "#36648B">标记整理</font></center>
**1、使用场景**
Full GC算法是由**标记清除算法（Mark-Sweep）**实现或是**标记清除/整理算法**混合实现。

**2、原理**
基于标记清除算法下，再将内存空间整理一遍，消灭内存碎片。



