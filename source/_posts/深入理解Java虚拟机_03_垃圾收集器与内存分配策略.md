---
title: 03 | 垃圾收集器与内存分配策略
date: 2019-11-26 00:11:49
tags: [JVM]
categories :
- 学习笔记
- JVM
- 深入理解Java虚拟机
---

<center> <h4><font color = "#36648B">✎</br>对象的死亡</center>
**1、引用计数法**
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，引用失效时，计数器值就减1。任何时刻计数器为0的对象就是不可能再被使用的。
但是引用计数法解决不了**相互循环引用**的问题。

**2、可达性分析算法**
这个算法就是以一系列的“**GC Root**”为起点，从这些节点向下搜索，当一个对象不可达时，则认为这个对象“已死”。

GC Root包括以下4种对象：
- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNl（即一般说的Native方法）引用的对象。


**3、引用的分类**
引用由强到若可以分为4种引用：
- 强引用。这个就是我们平常代码里面new的引用类型。
- 软引用。可用`SoftReference`类实现软引用。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行**第二次回收**。如果这次回收还没有足够的内存才会抛出内存溢出异常。
- 弱引用。可用`WeakReference`类实现弱引用。被弱引用关联的对象只能生存到**下一次垃圾收集发生之前**。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
> 看起来不可达（死亡）对象和弱引用的生存时间是一样的？

-  虚引用。可用`PhantomReference`实现虚引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时**收到一个系统通知**。

**4、对象被回收的过程**
- 可达性分析算法标志这个对象不可达（第一次标记）。
- 若对象覆盖了`finaliize()`方法并且之前没有执行过这个方法，那么将这个对象放到F-Queue队列中，让Finalizer线程去执行它的`finaliize()`方法。否则直接被回收。（对象的`finaliize()`只可能被调用一次）
- 稍后GC会对F-Queue队列的对象进行筛选，若依旧不可达，则将会被回收。
> 可在`finaliize()`方法中对这个对象进行“拯救”，即重新关联这个对象，让这个对象可达。

**5、Class的回收**
可用`-Xnoclassgc`控制JVM是否对Class对象进行回收。


<center> <h4><font color = "#36648B">✎✎</br>HotSpot的算法实现</center>
**1、枚举根节点**

HotSpot使用的是准确GC，使用一组称为**OopMap的数据结构**存储使用到的**引用以及引用的有效范围**。在枚举根节点时，只需要关注OopMap的信息即可。

**2、安全点**

程序执行过程中只有处于安全点时才会停下来进行GC。所以安全点与安全点之间如果存在了非常多的指令变化内容，JVM不必为这些指令都生成oopMap，只需要在第二个安全点之前，生成一个oopMap即可。

另外，让程序在到达安全点时“停下来”等待GC有两种方案：
- **抢先式中断**。GC直接让所有线程都中断，如果线程不在安全点上，则恢复它让它跑到安全点上再中断。

- **主动式中断**。线程到达一个安全点时，轮询一个标志，看是否需要GC，如果需要，就主动中断挂起。

现在的JVM基本上都是使用主动式中断策略。

> 从上面的信息可知，程序每到一个安全点必然会经过GC。（因为到了安全点就需要轮询）

**3、安全区域**

如果线程处于“不执行”的状态时，比如说处于Sleep、Blocked状态。那么就永远也跑不到安全点上了。JVM不可能为了等待这些线程跑到安全点上而不进行GC。所以就需要**安全区域**来解决。安全区域是指在一段代码片段之中，引用不会发生任何变化。

当程序执行到安全区域时，会标识自己已经进入了安全区域，若此时JVM要发起GC时，就会忽略这个线程。当线程要离开安全区域时，要检查JVM是否完成了根节点枚举，如果没有完成，则要接收到“可以离开安全区域”的信号后，程序才会往下执行。


<center> <h4><font color = "#36648B">✎✎✎</br>垃圾收集器</center>
|       名称        |   算法    | 是否并发 | 是否并行 | 是否需要STW | 作用区域 |
| :---------------: | :-------: | :------: | :------: | :---------: | :------: |
|      Serial       |   复制    |    否    |    否    |     是      |  新生代  |
|    Serial Old     | 标记-整理 |    否    |    否    |     是      |  老年代  |
|      ParNew       |   复制    |    是    |    否    |     是      |  新生代  |
| Parallel Scavenge |   复制    |    是    |          |             |  新生代  |
|   Parallel Old    | 标记-整理 |    是    |          |             |  老年代  |
|        CMS        | 标记-清除 |    是    | 不完全是 |             |  老年代  |

 

**1、Serial收集器**
虚拟机在Client模式下的默认新生代收集器。

**2、ParNew收集器**
Serial收集器的多线程版本。

**3、Serial Old收集器**
CMS收集器的后备预案。
可与Parallel Scavenge收集器组合。（已经比较少用）

**4、Parallel Scavenge收集器**
关注点在总的吞吐量。
适用不需要太多交互的用户。
一般来说GC的频率较低，所以每次GC导致的用户停顿时间会变长（频率低的话每次GC时新生代的内存空间就会比较大）。  

**5、Parallel Old收集器**
Parallel Scavenge收集器的老年代版本。

**6、CMS**
只有ParNew/Serial收集器可以与CMS收集器配合工作。
Serial Old收集器可作为CMS收集器的后备预案。

**收集过程：**
- 初始标记。标记GC Roots能直接关联到的对象。需要STW。
- 并发标记。进行GC Roots Tracing的过程。
- 重新标记。修正并发标记期间由于用户程序继续运行而导致标记产生变化的那一部分对象的标记记录。
- 并发清除。

**缺点**
- 需要大量CPU资源。
- 无法处理浮动垃圾。在并发清除阶段，产生的新的垃圾称为浮动垃圾，这部分垃圾只能等待下次GC清除。同时，因为并发手机时，用户程序还能继续运行，所以老年代要预留空间（预留空间的阈值是可以设置的）给用户程序，如果预留的空间不足以供用户程序运行，那么就会导致“Concurrent Mode Failure”失败。这时虚拟机就会启动后备方案：临时启用Serial Old收集器来对老年代进行垃圾回收。
- 由标记-清除算法带来的问题：内存碎片。也可以设置执行了多少次不进行压缩的full gc后，进行一次压缩。



**7、G1收集器**
特点：

- 并行与并发。
- 分代收集。
- 空间整合。整体上来看是使用标记-整理算法，局部上来说其实是使用了复制算法。
- 可预测的停顿。指定在M毫秒的时间段内，消耗的垃圾回收时间不会超过N毫秒。

G1会优先回收**价值最大**的Region。

老年代与新生代不再是物理隔离的。整个堆被分为N个Region。每个Region都有一个Remembered Set，记录其对其他Region的引用。

收集过程：
- 初始标记。
- 并发标记。
- 最终标记。
- 筛选回收。


<center> <h4><font color = "#36648B">✎✎✎✎</br>内存分配</center>
一般来说，Full GC前都会经过Minor GC，但并非绝对，在Parallel Scavenge收集策略里就有直接进行Full GC的策略。
Full GC的速度一般会比Minor GC慢10倍以上。

1、直接进入老年代的大对象
设置`-XX:PretenureSize Threshold`这个参数在分配内存空间时可令大于它的对象直接进入老年代。
> 这个参数只对Serial和ParNew两款收集器有效。

2、新生代对象何时进入老年代
- 存活年龄达到阈值。
- 