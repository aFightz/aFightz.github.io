---
title: 03 | 垃圾收集器与内存分配策略
date: 2019-11-26 00:11:49
tags: [JVM]
categories :
- 学习笔记
- JVM
- 深入理解Java虚拟机
---

<center> <h4><font color = "#36648B">✎</br>对象的死亡</center>
**1、引用计数法**
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，引用失效时，计数器值就减1。任何时刻计数器为0的对象就是不可能再被使用的。
但是引用计数法解决不了**相互循环引用**的问题。

**2、可达性分析算法**
这个算法就是以一系列的“**GC Root**”为起点，从这些节点向下搜索，当一个对象不可达时，则认为这个对象“已死”。

GC Root包括以下4种对象：
- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNl（即一般说的Native方法）引用的对象。


**3、引用的分类**
引用由强到若可以分为4种引用：
- 强引用。这个就是我们平常代码里面new的引用类型。
- 软引用。可用`SoftReference`类实现软引用。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行**第二次回收**。如果这次回收还没有足够的内存才会抛出内存溢出异常。
- 弱引用。可用`WeakReference`类实现弱引用。被弱引用关联的对象只能生存到**下一次垃圾收集发生之前**。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
> 看起来不可达（死亡）对象和弱引用的生存时间是一样的？

-  虚引用。可用`PhantomReference`实现虚引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时**收到一个系统通知**。

**4、对象被回收的过程**
- 可达性分析算法标志这个对象不可达（第一次标记）。
- 若对象覆盖了`finaliize()`方法并且之前没有执行过这个方法，那么将这个对象放到F-Queue队列中，让Finalizer线程去执行它的`finaliize()`方法。否则直接被回收。（对象的`finaliize()`只可能被调用一次）
- 稍后GC会对F-Queue队列的对象进行筛选，若依旧不可达，则将会被回收。
> 可在`finaliize()`方法中对这个对象进行“拯救”，即重新关联这个对象，让这个对象可达。

**5、Class的回收**
可用`-Xnoclassgc`控制JVM是否对Class对象进行回收。


<center> <h4><font color = "#36648B">✎</br>HotSpot的算法实现</center>

**1、枚举根节点**


