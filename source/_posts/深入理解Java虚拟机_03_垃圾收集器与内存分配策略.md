---
title: 03 | 垃圾收集器与内存分配策略
date: 2019-11-26 00:11:49
tags: [JVM]
categories :
- 学习笔记
- JVM
- 深入理解Java虚拟机
---

<center> <h4><font color = "#36648B">✎</br>对象的死亡</center>
**1、引用计数法**
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，引用失效时，计数器值就减1。任何时刻计数器为0的对象就是不可能再被使用的。
但是引用计数法解决不了**相互循环引用**的问题。

**2、可达性分析算法**
这个算法就是以一系列的“**GC Root**”为起点，从这些节点向下搜索，当一个对象不可达时，则认为这个对象“已死”。

GC Root包括以下4种对象：
- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNl（即一般说的Native方法）引用的对象。


**3、引用的分类**
引用由强到若可以分为4种引用：
- 强引用。这个就是我们平常代码里面new的引用类型。
- 软引用。可用`SoftReference`类实现软引用。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行**第二次回收**。如果这次回收还没有足够的内存才会抛出内存溢出异常。
- 弱引用。可用`WeakReference`类实现弱引用。被弱引用关联的对象只能生存到**下一次垃圾收集发生之前**。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
> 看起来不可达（死亡）对象和弱引用的生存时间是一样的？

-  虚引用。可用`PhantomReference`实现虚引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时**收到一个系统通知**。

**4、对象被回收的过程**
- 可达性分析算法标志这个对象不可达（第一次标记）。
- 若对象覆盖了`finaliize()`方法并且之前没有执行过这个方法，那么将这个对象放到F-Queue队列中，让Finalizer线程去执行它的`finaliize()`方法。否则直接被回收。（对象的`finaliize()`只可能被调用一次）
- 稍后GC会对F-Queue队列的对象进行筛选，若依旧不可达，则将会被回收。
> 可在`finaliize()`方法中对这个对象进行“拯救”，即重新关联这个对象，让这个对象可达。

**5、Class的回收**
可用`-Xnoclassgc`控制JVM是否对Class对象进行回收。


<center> <h4><font color = "#36648B">✎</br>HotSpot的算法实现</center>
**1、枚举根节点**

HotSpot使用的是准确GC，使用一组称为**OopMap的数据结构**存储使用到的**引用以及引用的有效范围**。在枚举根节点时，只需要关注OopMap的信息即可。

**2、安全点**

程序执行过程中只有处于安全点时才会停下来进行GC。所以安全点与安全点之间如果存在了非常多的指令变化内容，JVM不必为这些指令都生成oopMap，只需要在第二个安全点之前，生成一个oopMap即可。

另外，让程序在到达安全点时“停下来”等待GC有两种方案：
- **抢先式中断**。GC直接让所有线程都中断，如果线程不在安全点上，则恢复它让它跑到安全点上再中断。

- **主动式中断**。线程到达一个安全点时，轮询一个标志，看是否需要GC，如果需要，就主动中断挂起。

现在的JVM基本上都是使用主动式中断策略。

> 从上面的信息可知，程序每到一个安全点必然会经过GC。（因为到了安全点就需要轮询）

**3、安全区域**

如果线程处于“不执行”的状态时，比如说处于Sleep、Blocked状态。那么就永远也跑不到安全点上了。JVM不可能为了等待这些线程跑到安全点上而不进行GC。所以就需要**安全区域**来解决。安全区域是指在一段代码片段之中，引用不会发生任何变化。

当程序执行到安全区域时，会标识自己已经进入了安全区域，若此时JVM要发起GC时，就会忽略这个线程。当线程要离开安全区域时，要检查JVM是否完成了根节点枚举，如果没有完成，则要接收到“可以离开安全区域”的信号后，程序才会往下执行。


<center> <h4><font color = "#36648B">✎</br>垃圾收集器</center>
1、Serial收集器
复制算法。
单线程收集器。
进行垃圾回收时，必须暂停其他所有的工作线程。
新生代。
虚拟机在Client模式下的默认新生代收集器。


2、ParNew收集器
复制算法。
Serial收集器的多线程版本。
进行垃圾回收时，必须暂停其他所有的工作线程。

3、Serial Old收集器
标记-整理算法。
Serial收集器的老年代版本。
CMS收集器的后备预案。
可与Parallel Scavenge收集器组合。（已经比较少用）

4、Parallel Scavenge收集器
复制算法。
多线程。
新生代收集器。
关注点在总的吞吐量。
适用不需要太多交互的用户。
一般来说GC的频率较低，所以每次GC导致的用户停顿时间会变长（频率低的话每次GC时新生代的内存空间就会比较大）。

5、Parallel Old收集器
标记-整理。
Parallel Scavenge收集器的老年代版本。


6、CMS
只有ParNew/Serial收集器可以与CMS收集器配合工作。
Serial Old收集器可作为CMS收集器的后备预案。
标记-清除。
老年代。 
