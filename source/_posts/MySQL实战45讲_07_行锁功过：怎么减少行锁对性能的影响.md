---
title: 07 | 行锁功过：怎么减少行锁对性能的影响
date: 2019-01-22 14:33:43
tags: [MySQL]
categories :
- 学习笔记
- MySQL
- MySQL实战45讲
---

不是所有引擎都支持行锁，MyIASM就不支持行锁。


两阶段锁
在InnoDB事务中，行锁是在需要的时候才加上的，但要等到事务结束后才释放。

如果事务中需要锁多个行，要把最可能引起锁冲突、最可能影响并发度的锁尽量往后放。


死锁与死锁检测
死锁解决策略
设置innodb_lock_wait_timeout。（锁等待最长时间，默认为50S）
设置innodb_deadlock_detect为on（默认为on），开启死锁检测逻辑：发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。

死锁检测过程：每当一个事务被锁的时候，需要看看它锁依赖的线程有无被别人锁住，如此循环，最后判断是否有出现循环等待。假设有1000个线程同时更新同一行时，死锁检测就是100万这个量级的。


如果解决热点行更新导致的性能问题
确保这个业务一定不会出现死锁，可以临时把死锁关掉（有一定风险）。
控制并发度：
从客户端上控制并发度，比如说设置10个并发，但这样需要确保客户端不能有很多。
从服务端上控制并发度，这个比较困难。要修改MYSQL源码，或者在中间件实现。
从设计上优化这个问题：比如说剩余数量这一行，可以分为10行。统计的时候去统计这10行的和，写的时候随机写入其中一行，这样可以把冲突降低为原来的10分之1。











