---
title: 07 | 行锁功过：怎么减少行锁对性能的影响
date: 2019-01-22 14:33:43
tags: [MySQL]
categories :
- 学习笔记
- MySQL
- MySQL实战45讲
---

MySQL 的行锁是在引擎层由各个引擎自己实现的，不是所有引擎都支持行锁，MyIASM就不支持行锁。


<center> <h4><font color = "#36648B">✎</br>两阶段锁</center>

在InnoDB事务中，行锁是在需要的时候才加上的，但要等到事务结束后才释放。这个就是两阶段锁协议。

innodb行级锁是通过锁索引记录实现的。如果update的列没建索引，即使只update一条记录也会锁定整张表。
> 比如说`update t set t.name='abc' where t.name='cde';`这条语句，就会造成表锁，防止update的同时又新插入name为'cde'的记录。但是`update t set t.name='abc' where t.name='cde' limit 1;`这样就变成行锁了。

如果事务中需要锁多个行，要把最可能引起锁冲突、最可能影响并发度的锁尽量往后放。
> 总的来说就是尽量减少持有行锁的时间。


<center> <h4><font color = "#36648B">✎✎</br>死锁与死锁检测</center>

**1、死锁解决策略**
- 设置**innodb_lock_wait_timeout**。（锁等待最长时间，默认为50S）
- 设置**innodb_deadlock_detect**为on（默认为on），开启死锁检测逻辑：发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。

死锁检测过程：每当一个事务被锁的时候，需要看看它锁依赖的线程有无被别人锁住，如此循环，最后判断是否有出现循环等待。假设有1000个线程同时更新同一行时，死锁检测就是100万这个量级的。


<center> <h4><font color = "#36648B">✎✎✎</br>如何解决热点行更新导致的性能问题</center>
- 确保这个业务一定不会出现死锁，可以临时把死锁关掉（有一定风险）。
- 控制并发度：
  - 从客户端上控制并发度，比如说设置10个并发，但这样需要确保客户端不能有很多。
  - 从服务端上控制并发度，这个比较困难。要修改MYSQL源码，或者在中间件实现。
- 从设计上优化这个问题：比如说剩余数量这一行，可以分为10行。统计的时候去统计这10行的和，写的时候随机写入其中一行，这样可以把冲突降低为原来的10分之1。











