---
title: 02 | 系统调用、异常、中断
date: 2019-08-20 23:30:48
tags: [操作系统]
categories :
- 学习笔记
- 操作系统
---

#### <center><font color = "#36648B">✎</font><br/><font color = "#36648B">定义</font></center>
- **系统调用**（来源于应用程序）：应用程序主动向操作系统发出服务请求。
- **异常**（来源于不良的应用程序）：非法指令或者其他坏的处理状态（如：内存出错）。
- **中断**（来源于外设）：来自不同的硬件设备的计时器或网络的中断。
> 应用程序不能直接访问外设，需要通过内核间接的访问。

#### <center><font color = "#36648B">✎✎</font><br/><font color = "#36648B">应用程序的响应</font></center>
- **中断**：应用程序持续执行，中断对用户应用程序是透明的（用户应用程序感知不到中断），所以说中断对于应用程序来说是**异步**的。
- **异常**：杀死或者重新执行意想不到的应用程序指令。异常对于应用程序来说是**同步**的。
- **系统调用**：应用程序等待（阻塞）或者持续运行。所以系统调用对于应用程序来说既可以是**同步**也可以是**异步**的。

#### <center><font color = "#36648B">✎✎✎</font><br/><font color = "#36648B">中断处理过程</font></center>
- 操作系统首先建立一个中断映射表，key是中断号，value是对应的服务例程。
- 外设设置中断标记，CPU根据中断标记会产生一个对应的中断号，并发送给操作系统。
- 操作系统保存当前执行程序的执行现场。
- 操作系统根据中断号找到对应的处理服务例程。
- 操作系统执行中断服务例程。
- 清除中断标记。  
- 操作系统恢复之前被打断程序的执行现场。

#### <center><fnt color = "#36648B">✎✎✎✎</font><br/><font color = "#36648B">异常处理过程</font></center>
- 操作系统首先建立一个异常映射表，key是异常编号，value是对应的服务例程。
- 程序执行过程中发生了异常时，会发送一个异常编号给操作系统。
- 操作系统保存当前执行程序的执行现场。
- 操作系统根据异常号找到对应的处理服务例程。
- 操作系统执行异常服务例程，会有以下两种结果：
  - 杀死产生了异常的程序。
  - 重新执行异常指令，恢复之前异常程序的执行现场。


#### <center><fnt color = "#36648B">✎✎✎✎</font><br/><font color = "#36648B">系统调用</font></center>
同样的，操作系统也会为系统调用建立一个映射表，key是调用号，value是对应的处理例程。
**1、CPU的状态**
CPU有两种状态：用户态和内核态。
- 用户态：不能执行一些特权级的指令，不能直接访问IO。
- 内核态：可以执行所有的指令，可以直接访问IO。

当应用程序调用一个系统调用时，会完成从用户态到内核态的转换。


2、**系统调用与函数调用的区别**
- 系统调用需要切换堆栈，需要将用户态转换成内核态。
- 函数调用是在一个堆栈里面进行的。
所以系统调用的开销会比较大。

#### <center><fnt color = "#36648B">✎✎✎✎</font><br/><font color = "#36648B">系统调用、异常、中断的开销</font></center>
- 在执行时间上的开销超过函数调用。
- 需要建立中断、异常、系统调用号与对应服务例程映射表。
- 建立、维护内核堆栈。（这个堆栈与应用程序的堆栈是隔离的）
- 发生系统调用时，操作系统需要验证传进来的参数是否合法。
- 系统调用完成后返回一些数据给应用程序时，需要把这些数据从内核堆栈复制到用户堆栈。
- 更新页面映射权限。（这个后面会讲）
- TLB。（这个后面会讲）