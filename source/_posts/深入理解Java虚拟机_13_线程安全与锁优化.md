---
title: 13 | 线程安全与锁优化
date: 2020-01-02 22:54:11
tags: [JVM]
categories :
- 学习笔记
- JVM
- 深入理解Java虚拟机
---


Thread类的suspend()与resume()方法会产生死锁，已废弃。

Java的线程是映射到操作系统的原生线程之上的，所说要阻塞或唤醒一个线程，需要从用卢态转换到核心态中，非常耗费时间。
Java在通知操作系统阻塞线程之前加入一段自旋等待过程，避免频繁地切入到核心态之中。

互斥同步
相比于synchronized，ReentrantLock有以下三个优点：
等待可中断。
可实现公平锁。
  公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。，。
  非公平锁：与公平锁相反，是随机获取锁的。在锁被释放时，任何一个等待锁的线程都有机会获得锁。
  > synchronized中的锁是非公平的。ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。
  
锁可以绑定多个条件。
 
1.6后synchronized与ReentrantLock的性能就基本持平了。

非阻塞同步
互斥同步属于悲观并发策略，非阻塞同步属于乐观并发策略。
乐观并发策略只能靠硬件来完成（CAS指令）。

CAS操作过程：
CAS指令需要有3个操作数，分别是内存位置（用v表示）、旧的预期值（用A表示）和新值（用B表示）。
CAS指令执行时，当且仅当v符合旧预期值A时，处理器用新值B更新V的值；否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值，主述的处理过程是一个原子操作。


CAS操作由sun.misc.Unsafe类里面的compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供。

Atomic的incrementAndGet方法源码

public final int incrementAndGet(){
    for(;;){
        int current = get(); 
        int next=current +1; 
        if (compareAndSet(current,next))
            return next;
    }
}

但是CAS存在ABA问题，即一个值修改的顺序为A->B->A时，当前赋值无法检测到，仍然认为是正确的赋值。
但是一般情况下这种情况都可以忽略，若确实有场景不允许这样的情况，也可以使用AtomicStampedReference实现，它通过控制版本号来实现CAS。



自旋锁与自适应锁
自旋锁
挂起线程和恢复线程的操作都需要转入内核态中完成，如果共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。
如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋）。

自适应自旋锁
若虚拟机会判断如果此线程的此次自旋很有可能会成功，则会让自旋循环更多次，否则就会循环更少次。

锁消除
锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

锁粗化
如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。

轻量级锁
传统的锁机制称为重量级锁。

当同步对象没有被锁定时，锁标志位为01。
当线程尝试去锁定同步对象时，若判断同步对象未锁定，会使用CAS尝试将MarkWord更新为指向Lock Record的指针，（Lock Record是线程在栈空间中建立的锁记录，其实就是Mark Word的副本）并将锁标志位置为00。
若发现锁标志位为00（轻量级锁定），或者说CAS更新同步对象失败，则判断是不是本线程持有锁（同过判断MarkWord的指针是否指向本线程的Lock Record即可知），如果不是，则将MarkWord存储为指向重量级锁（互斥量）的指针，将锁标志置为10，此线程以及后面的线程要进入阻塞状态。
当持有锁对象执行完，需要释放锁时，使用CAS将Lock Record替换对象的MarkWord指针，如果替换不成功（说明有其他线程尝试获取此锁，MarkWord指针已被改变），则要释放锁的同时，还要唤醒其他等待的线程。

如果在绝大部分不存在竞争的情况下，轻量级锁是更好的，但是如有频繁的有竞争，轻量级锁会比重量级锁更慢，因为此时轻量级锁不仅有互斥量的开销，还有CAS操作的开销。



偏向锁
当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进人这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。

当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。撤销偏向（Revoke Bias）后恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00）的状态，后续的同步操作就如上面介绍的轻量级锁那样执行。

![](深入理解Java虚拟机_13_线程安全与锁优化\深入理解Java虚拟机_13_线程安全与锁优化.png)

对于大多数锁都是被同一线程获取的情况，使用偏向锁更好。
