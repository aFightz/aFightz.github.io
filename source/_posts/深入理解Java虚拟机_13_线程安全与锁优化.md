---
title: 13 | 线程安全与锁优化
date: 2020-01-02 22:54:11
tags: [JVM]
categories :
- 学习笔记
- JVM
- 深入理解Java虚拟机
---


Thread类的`suspend()`与`resume()`方法会产生死锁，已废弃。

Java的线程是映射到操作系统的原生线程之上的，所说要阻塞或唤醒一个线程，需要从**用户态转换到核心态**中，非常耗费时间。
Java在通知操作系统阻塞线程之前加入一段**自旋等待** 过程，避免频繁地切入到核心态之中。

<center> <h4><font color = "#36648B">✎</br>互斥同步</center>

相比于synchronized，ReentrantLock有以下三个优点：
- 等待可中断。
- 可实现公平锁。
  - 公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。，。
  - 非公平锁：与公平锁相反，是随机获取锁的。在锁被释放时，任何一个等待锁的线程都有机会获得锁。
  > synchronized中的锁是非公平的。ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。
  
- 锁可以绑定多个条件。
 
1.6后synchronized与ReentrantLock的性能就基本持平了。

<center> <h4><font color = "#36648B">✎✎</br>非阻塞同步</center>

互斥同步属于**悲观并发策略**，非阻塞同步属于**乐观并发策略**。
乐观并发策略只能靠硬件来完成（**CAS指令**）。

**1、CAS操作过程：**
CAS指令需要有3个操作数，分别是内存位置（用v表示）、旧的预期值（用A表示）和新值（用B表示）。
CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值；否则它就不执行更新。无论是否更新了V的值，都会返回V的旧值。


CAS操作由`sun.misc.Unsafe`类里面的`compareAndSwapInt()`和`compareAndSwapLong()`等几个方法包装提供。

**2、Atomic的incrementAndGet方法源码**
```java
public final int incrementAndGet(){
    for(;;){
        int current = get(); 
        int next=current +1; 
        if (compareAndSet(current,next))
            return next;
    }
}
```

**3、ABA问题**
CAS存在ABA问题，即一个值修改的顺序为A->B->A时，当前赋值无法检测到，仍然认为是正确的赋值。
但是一般情况下这种情况都可以忽略，若确实有场景不允许这样的情况，也可以使用`AtomicStampedReference`实现，它通过控制版本号来实现CAS。



<center> <h4><font color = "#36648B">✎✎</br>锁</center>

**1、自旋锁**
挂起线程和恢复线程的操作都需要转入内核态中完成，如果共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋）。
自旋锁默认是开启的。

**2、自适应自旋锁**
若虚拟机会判断如果此线程的此次自旋很有可能会成功，则会让自旋循环更多次，否则就会循环更少次。

**3、锁消除**
锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

**4、锁粗化**
如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。

**5、轻量级锁**
轻量级锁是默认开启的。
传统的锁机制称为重量级锁。重量级锁需要申请系统的互斥量（系统调用）。

当同步对象没有被锁定时，锁标志位为**01**。
当线程尝试去锁定同步对象时：
- 若判断同步对象未锁定，会使用CAS尝试将MarkWord更新为指向Lock Record的指针，（Lock Record是线程在栈空间中建立的锁记录，其实就是Mark Word的副本）并将锁标志位置为**00**。
- 若发现锁标志位为**00**（轻量级锁定），或者说CAS更新同步对象失败，则判断是不是本线程持有锁（通过判断MarkWord的指针是否指向本线程的Lock Record即可知），如果不是，则将MarkWord存储为指向重量级锁（互斥量）的指针，将锁标志置为**10**，此线程以及后面的线程要进入阻塞状态。

当持有锁对象执行完，需要释放锁时，使用CAS将Lock Record替换对象的MarkWord指针，如果替换不成功（说明有其他线程尝试获取此锁，MarkWord指针已被改变），则要释放锁的同时，还要唤醒其他等待的线程。
> 互斥锁还需要唤醒？

如果在绝大部分不存在竞争的情况下，轻量级锁是更好的，但是如有频繁的有竞争，轻量级锁会比重量级锁更慢，因为此时轻量级锁不仅有互斥量的开销，还有CAS操作的开销。



**6、偏向锁**
当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为**01**，即**偏向模式**。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进人这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。

当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。撤销偏向（Revoke Bias）后恢复到未锁定（标志位为**01**）或轻量级锁定（标志位为**00**）的状态，后续的同步操作就如上面介绍的轻量级锁那样执行。

![](深入理解Java虚拟机_13_线程安全与锁优化\偏向锁、轻量级锁的状态转化及对象Mark Word的关系.png)

对于大多数锁都是被同一线程获取的情况，使用偏向锁更好。
