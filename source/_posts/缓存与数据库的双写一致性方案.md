---
title: 缓存与数据库的双写一致性方案
date: 2019-08-06 15:05:53
tags: [缓存架构]
categories :
- 学习笔记
- 博客与公众号
---

#### <center><font color = "#36648B">✎</font><br/><font color = "#36648B">读/写操作的逻辑</font></center>
**读操作**基本上都是这样的逻辑：先读缓存，读不到就取DB读，然后将读到的值写到缓存。

**写操作**根据业务场景不同可以有以下几个逻辑：
- 先更新缓存，在更新数据库。
- 先更新数据库，再更新缓存。
- 先删除缓存，再更新数据库。
- 先更新数据库，再删除缓存。

总的来说就是**更新/删除缓存**与**更新数据库**先后顺序的排列组合。


#### <center><font color = "#36648B">✎✎</font><br/><font color = "#36648B">缓存设置过期时间</font></center>
从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。但是某些业务场景如果需要缓存的及时更新的话，这种策略可能不能满足场景。因为在缓存过期的这段时间内，业务逻辑读取的缓存都是脏数据。

#### <center><font color = "#36648B">✎✎✎</font><br/><font color = "#36648B">先更新缓存，在更新数据库</font></center>

#### <center><font color = "#36648B">✎✎✎✎</font><br/><font color = "#36648B">先更新数据库，再更新缓存</font></center>
从以下两个角度分析其弊端：
- **线程安全角度**
同时有请求A和请求B进行更新操作，那么会出现：
 - 线程A更新了数据库。
 - 线程B更新了数据库。
 - 线程B更新了缓存。
 - 线程A更新了缓存。
 
  会导致缓存与数据库的数据库不一致。出现脏数据。

- **业务角度**
如果业务场景中写场景比较多，而读场景比较少，缓存会被频繁的更新，导致浪费性能。（如果更新要花费的代价很大，比如要连表查询之类的，就更浪费性能了）

第一种弊端有可能是网络的原因或者是计算机线程调度的原因导致的，无法解决。第二种弊端更不可能解决。所以这种策略是不推荐的。

#### <center><font color = "#36648B">✎✎✎✎✎</font><br/><font color = "#36648B">先删除缓存，再更新数据库</font></center>
同时有一个请求A进行更新操作，另一个请求B进行查询操作，会出现以下问题：
**1、读写不分离**
 - 请求A进行写操作，删除缓存。
 - 请求B查询发现缓存不存在。
 - 请求B去数据库查询得到旧值。
 - 请求B将旧值写入缓存。
 - 请求A将新值写入数据库。

会导致缓存与数据库的数据库不一致。出现脏数据。

可采用**延时双删**解决上述问题：
 - 先淘汰缓存。
 - 再写数据库（这两步和原来一样）。
 - 休眠N秒，再次淘汰缓存。（休眠时间=读数据业务逻辑的耗时+几百ms即可。）

**2、读写分离**
- 请求A进行写操作，删除缓存。
- `请求A将数据写入数据库`。
- 请求B查询缓存发现，缓存没有值。
- 请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值。
- 请求B将旧值写入缓存。
- 数据库完成主从同步，从库变为新值。

会导致缓存与数据库的数据库不一致。出现脏数据。

同样可采用延时双删解决上述问题，只是从上述可知，休眠时间应该=读数据业务逻辑的耗时+主从同步耗时+几百ms。

**3、总结**
虽然可以用延时双删的策略解决大部分问题，但是还是存在以下弊端：
- 休眠时间内可能有读业务把最新数据给缓存进去了，这种情况第二次删除将会是无意义的。
 - 这种情况可以忽略。
- 休眠时间非常难保证是完全正确的，万一有某个读业务花费大量时间，那么仍会有脏数据的风险。
 - 这种情况很难避免。
- 第二次删除的时候，如果是同步休眠那么会造成吞吐量降低。
 - 解决办法是异步去作第二次删除。
- 若第二次删除失败，仍旧会造成脏数据。
 - 这种情况可以用重试机制解决。

