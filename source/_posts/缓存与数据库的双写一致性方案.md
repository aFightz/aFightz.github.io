---
title: 缓存与数据库的双写一致性方案
date: 2019-08-06 15:05:53
tags: [缓存架构]
categories :
- 学习笔记
- 博客与公众号
---

#### <center><font color = "#36648B">✎</font><br/><font color = "#36648B">读/写操作的逻辑</font></center>
**读操作**基本上都是这样的逻辑：先读缓存，读不到就去DB读，然后将读到的值写到缓存。

**写操作**根据业务场景不同可以有以下几个逻辑：
- 先更新缓存，再更新数据库。
- 先更新数据库，再更新缓存。
- 先删除缓存，再更新数据库。
- 先更新数据库，再删除缓存。

总的来说就是**更新/删除缓存**与**更新数据库**先后顺序的排列组合。


#### <center><font color = "#36648B">✎✎</font><br/><font color = "#36648B">缓存设置过期时间</font></center>
从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。但是某些业务场景如果需要缓存的及时更新的话，这种策略可能不能满足场景。因为在缓存过期的这段时间内，业务逻辑读取的缓存都是脏数据。

#### <center><font color = "#36648B">✎✎✎</font><br/><font color = "#36648B">先更新缓存，在更新数据库</font></center>

#### <center><font color = "#36648B">✎✎✎✎</font><br/><font color = "#36648B">先更新数据库，再更新缓存</font></center>
从以下两个角度分析其弊端：
- **线程安全角度**
同时有请求A和请求B进行更新操作，那么会出现：
 - 线程A更新了数据库。
 - 线程B更新了数据库。
 - 线程B更新了缓存。
 - 线程A更新了缓存。
 
  会导致缓存与数据库的数据库不一致。出现脏数据。

- **业务角度**
如果业务场景中写场景比较多，而读场景比较少，缓存会被频繁的更新，导致浪费性能。（如果更新要花费的代价很大，比如要连表查询之类的，就更浪费性能了）

第一种弊端有可能是网络的原因或者是计算机线程调度的原因导致的。
 - 可以考虑这样解决这个问题，把更新缓存放到队列中执行，通过串行来解决并行的问题。通过在代码里加锁保证更新数据库与push进队列的操作是原子的。但是这个恐怕会非常影响吞吐量（因为每次只能有一个线程在更新数据库与push进队列）。
 - 如果说数据库每次更新有一个唯一的自增的update version，（如数据记录的update time等），可以不用加锁直接push进队列。队列另一端的消费者只对update version比上一个update version大的数据更新进缓存。

第二种弊端是不可能解决。所以对于大多数场景这种策略是不推荐的。

#### <center><font color = "#36648B">✎✎✎✎✎</font><br/><font color = "#36648B">先删除缓存，再更新数据库</font></center>
同时有一个请求A进行更新操作，另一个请求B进行查询操作，会出现以下问题：
**1、读写不分离**
 - 请求A进行写操作，删除缓存。
 - 请求B查询发现缓存不存在。
 - 请求B去数据库查询得到旧值。
 - 请求B将旧值写入缓存。
 - 请求A将新值写入数据库。

会导致缓存与数据库的数据库不一致。出现脏数据。

可采用**延时双删**解决上述问题：
 - 先淘汰缓存。
 - 再写数据库（这两步和原来一样）。
 - 休眠N秒，再次淘汰缓存。（休眠时间=读数据业务逻辑的耗时+几百ms即可。）

**2、读写分离**
- 请求A进行写操作，删除缓存。
- `请求A将数据写入数据库`。
- 请求B查询缓存发现，缓存没有值。
- 请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值。
- 请求B将旧值写入缓存。
- 数据库完成主从同步，从库变为新值。

会导致缓存与数据库的数据库不一致。出现脏数据。

同样可采用延时双删解决上述问题，只是从上述可知，休眠时间应该=读数据业务逻辑的耗时+主从同步耗时+几百ms。

**3、总结**
虽然可以用延时双删的策略解决大部分问题，但是还是存在以下弊端：
- 休眠时间内可能有读业务把最新数据给缓存进去了，这种情况第二次删除将会是无意义的。
 - 这种情况可以忽略。
- 休眠时间非常难保证是完全正确的，万一有某个读业务花费大量时间，那么仍会有脏数据的风险。
 - 这种情况很难避免。
- 第二次删除的时候，如果是同步休眠那么会造成吞吐量降低。
 - 解决办法是异步去作第二次删除。
- 若第二次删除失败，仍旧会造成脏数据。
 - 这种情况可以用重试机制解决。

#### <center><font color = "#36648B">✎✎✎✎✎✎✎</font><br/><font color = "#36648B">先更新数据库，再删缓存</font></center>
这种策略就是我们常说的**Cache-Aside pattern**：
- 失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
- 命中：应用程序从cache中取数据，取到后返回。
- 更新：先把数据存到数据库中，成功后，再让缓存失效。

同时有一个请求A进行更新操作，另一个请求B进行查询操作，会出现以下问题：
- 缓存刚好失效。
- 请求A查询数据库，得一个旧值。
- 请求B将新值写入数据库。
- 请求B删除缓存。
- 请求A将查到的旧值写入缓存。

从而导致脏数据。
但是一般来说上述情况不会出现，因为写入数据总是会比查询数据慢的，所以请求A查询数据库的用时一般不会比请求B写入数据库的用时少。但不能完全保证。

我们也可以用上述说到的异步延时双删去解决这个问题，同样的，我们也不能解决缓存删除失败的问题。


#### <center><font color = "#36648B">✎✎✎✎✎✎✎✎</font><br/><font color = "#36648B">重试机制解决删除失败问题</font></center>

**1、方案一**
![](缓存与数据库的双写一致性方案\重试删除1.png)
该方案有一个缺点，对业务线代码造成大量的侵入，所以可以优化为方案二。

**2、方案二**
![](缓存与数据库的双写一致性方案\重试删除2.png)
上述的订阅binlog程序在mysql中有现成的中间件叫`canal`，可以完成订阅binlog日志的功能。