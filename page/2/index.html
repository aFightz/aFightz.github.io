<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="aFightz">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="aFightz">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="aFightz">






  <link rel="canonical" href="http://yoursite.com/page/2/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>aFightz</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">aFightz</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/24/深入理解Java虚拟机_12_java内存模型与线程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/24/深入理解Java虚拟机_12_java内存模型与线程/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">12 | java内存模型与线程</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-24 00:09:34" itemprop="dateCreated datePublished" datetime="2019-12-24T00:09:34+08:00">2019-12-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 19:22:36" itemprop="dateModified" datetime="2020-01-07T19:22:36+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/深入理解Java虚拟机/" itemprop="url" rel="index"><span itemprop="name">深入理解Java虚拟机</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <center> <h4><font color="#36648B">✎<br>内存间交互操作</font></h4></center>

<p><strong>1、jvm保证下面8种操作是原子的</strong>：</p>
<ul>
<li><strong>lock</strong>（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li><strong>unlock</strong>（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li><strong>read</strong>（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li><strong>load</strong>（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li><strong>use</strong>（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li><strong>assign</strong>（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li><strong>store</strong>（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li>
<li><strong>write</strong>（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放人主内存的变量中。</li>
</ul>
<p>2、<strong>执行上述8种操作时必须满足下面的规则</strong>：</p>
<ul>
<li><code>read-&gt;load</code>，<code>assign-&gt;store-&gt;write</code>这两组操作是固定的，不会少，顺序也不会变。</li>
<li>在use的前面一定会有初始化（load或assign）的操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li>
<li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</li>
</ul>
<blockquote>
<p>假设线程中访问一个10MB的对象，也会把这10MB的内存复制二份拷出来吗？<br>答：事实上并不会如此，这个对象的引用、对象中某个在线程访问到的字段是存可能存在拷的，但不会有虚拟机实现成把整个对象拷一次。</p>
</blockquote>
<center> <h4><font color="#36648B">✎✎<br>volatile</font></h4></center>

<p>在JDK1.5之前，volatile的不能完全避免重排序，所以不能安全地使用DDL（双锁检测）来实现单例模式。</p>
<p>在对volatile变量进入赋值操作时，紧跟在后面会插入一条内存屏障指令（从汇编代码上体现的是一条lock前缀的指令）。</p>
<ul>
<li>这个指令会使本cpu的cache写入主内存，这个写入动作会导致其他cpu相应的cache无效化。<blockquote>
<p>无效化意思就是说会重新从主内存读相应的cache？那么volatile的读又起到什么作用？</p>
</blockquote>
</li>
<li>同时这个lock前缀的屏障也会使后续的指令不会重排序到内存屏障前。<blockquote>
<p>每对volatile写一次就会产生一条内存屏障指令。</p>
</blockquote>
</li>
</ul>
<p>读写volatile变量要满足以下规则：</p>
<ul>
<li><code>read-&gt;load-&gt;use</code>（读）、<code>assign-&gt;store-&gt;write</code>(写)一定会是连续一起出现的。</li>
<li>假设有volatile类型变量A与B，从代码角度上来看先对A进行读/写，再对B进行读/写，那么这两者不会被重排序。<blockquote>
<p>如果对读取两个volatile变量，那么这两次读取会被重排序吗？</p>
</blockquote>
</li>
</ul>
<center> <h4><font color="#36648B">✎✎✎<br>synchronized</font></h4></center>

<p>synchronized编译成字节码就是<strong>monitorenter</strong>与<strong>monitorexit</strong>。</p>
<center> <h4><font color="#36648B">✎✎✎✎<br>happens-before</font></h4></center>

<ul>
<li><strong>程序次序规则</strong>。在一个线程中，按照控制流的顺序，书写在前面的操作先行发生于书写在后面的操作。</li>
<li><strong>管程锁定规则</strong>。一个unlock操作先行发生于后面对同一个锁的lock操作。这里所说的“后面”是指时间上的后面。</li>
<li><strong>volatile变量规则</strong>。对一个volatile变量的写操作先行发生于后面对这个变量的读操作。这里所说的“后面”是指时间上的后面。</li>
<li><strong>线程启动规则</strong>。<code>Thread的start()</code>方法先行发生于此线程的每一个动作。</li>
<li><strong>线程终止规则</strong>。线程中的所有操作都先行发生于对此线程的终止检测。（可以通过<code>Thread.join()</code>、<code>Thread.isAlive()</code>检测线程是否终止）。</li>
<li><strong>线程中断规则</strong>。对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断时间的发生(通过<code>Thread.interrupted()</code>等方法检测到是否有中断发生)。</li>
<li><strong>对象终结规则</strong>。一个对象的初始化完成(构造函数执行结束)先行发生于它的<code>finalize()</code>方法。</li>
<li><strong>传递性</strong>。如果A先于B、B先于C，那么A先于C。  </li>
</ul>
<blockquote>
<p>先行发生的意思通俗点来说就是：如果A先行发生于B，那么A对B<strong>可见</strong>。即A的操作能被B“观察”到。</p>
</blockquote>
<p><center> <h4><font color="#36648B">✎✎✎✎✎<br>线程的实现</font></h4></center><br>线程是比进程更轻量级的调度执行单位。<br>线程是CPU调度的基本单位。</p>
<p><strong>1、线程的种类</strong></p>
<ul>
<li><strong>内核线程</strong>：即由操作系统内核来完成线程切换与线程调度。</li>
<li><strong>轻量级进程</strong>：作为内核线程的高级接口，轻量级进程与内核线程是1:1的关系，轻量级进程是基于内核线程实现的，所以对线程的操作都要进行系统调用（需要再用户态和内核态相互切换）。</li>
<li><strong>用户线程</strong>：线程的创建、切换、调度等操作都由用户程序来管理，可以不需要进行系统调用（切换到内核态），所以线程操作是非常快速且低消耗的，可以支持规模更大的线程数量。与进程的关系是1：N。但是无法使用内核的一些功能（如处理器映射等）</li>
</ul>
<p><strong>2、线程的实现</strong><br>实现线程主要有3种方式：</p>
<ul>
<li>内核线程实现。但是一般不会直接使用线程，而是通过轻量级线程去访问内核线程。<blockquote>
<p>其实也可以说是1:1的轻量级线程实现。</p>
</blockquote>
</li>
</ul>
<p><img src="/2019/12/24/深入理解Java虚拟机_12_java内存模型与线程/轻量级进程与内核线程之间的关系.png" alt=""></p>
<ul>
<li><p>用户线程实现。<br><img src="/2019/12/24/深入理解Java虚拟机_12_java内存模型与线程/进程与用户线程之间的关系.png" alt=""></p>
</li>
<li><p>用户线程加轻量级进程混合实现。</p>
</li>
</ul>
<p><img src="/2019/12/24/深入理解Java虚拟机_12_java内存模型与线程/用户线程与轻量级进程之间的关系.png" alt=""></p>
<p><strong>2、java线程实现</strong><br>目前java线程是使用一对一线程模型实现的，即<strong>一条java线程映射为一条轻量级进程</strong>。</p>
<p><strong>3、java线程调度</strong><br>主要调度方式有两种：</p>
<ul>
<li><strong>协同式线程调度</strong>：线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。<ul>
<li>好处：切换操作对线程自己是可知的，所以没有线程同步的问题。</li>
<li>坏处：线程执行时间不可控制，容易造成系统阻塞。</li>
</ul>
</li>
<li><strong>抢占式线程调度</strong>：每个线程将由系统来分配执行时间，线程的切换由系统决定。<ul>
<li>好处：线程的执行时间是系统可控的,不容易造成阻塞。<blockquote>
<p>Java使用的线程调度方式就是抢占式调度。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>4、线程优先级</strong><br> java本身有10个优先级。但实际上并不是太靠谱，因为原生系统可能并没有那么多优先级。那么在做优先级映射的时候，有可能系统的一个优先级对应java的多个优先级。某些系统在特定情况下也不是完全按照线程优先级来执行线程调用的。</p>
<p> <strong>5、状态装换</strong><br>java语言定义了5种状态：<br>新建（New）。<br>运行（Runnable）。<br>无限期等待（Waiting）。以下方法会导致线程陷入无限期的等待状态：</p>
<ul>
<li>没有设置Timeout参数的Object.wait()方法。</li>
<li>没有设置Timeout参数的Thread.join()方法。</li>
<li>LockSupport.park()方法。</li>
</ul>
<p>限期等待（Timed Waiting）。以下方法会导致线程陷入限期等待状态：</p>
<ul>
<li>Thread.sleep()方法。</li>
<li>设置了Timeout参数的Object.wait()方法。设置了Timeout参数的Thread.join()方法。</li>
<li>LockSupport.parkNanos()方法。</li>
<li>LockSupport.parkUntil()方法。</li>
</ul>
<p>阻塞（Blocked）。“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。</p>
<p>结束（Terminated）。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/15/深入理解Java虚拟机_07_虚拟机类加载机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/15/深入理解Java虚拟机_07_虚拟机类加载机制/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">07 | 虚拟机类加载机制</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-15 23:16:45" itemprop="dateCreated datePublished" datetime="2019-12-15T23:16:45+08:00">2019-12-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/深入理解Java虚拟机/" itemprop="url" rel="index"><span itemprop="name">深入理解Java虚拟机</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <center> <h4><font color="#36648B">✎<br>类的生命周期</font></h4></center>

<ul>
<li>加载。</li>
<li>连接。<ul>
<li>验证。</li>
<li>准备。</li>
<li>解析。</li>
</ul>
</li>
<li>初始化。</li>
<li>使用。</li>
<li>卸载。<blockquote>
<p>解析阶段有时会在初始化后面。<br>加载阶段与连接阶段是<strong>交叉进行</strong>的。</p>
</blockquote>
</li>
</ul>
<p>对<code>static int a = 1;</code>这样的语句，在准备阶段为把a赋值为0，而在初始化阶段才会赋值为1。但是如果是这样的语句<code>final static int a = 1;</code>，在准备阶段就会直接赋值为1。</p>
<center> <h4><font color="#36648B">✎✎<br>解析</font></h4></center>

<p><strong>1、符号引用的解析</strong><br>对于符号引用的解析，会对第一次解析的结果进行缓存。（除了<code>invokedynamic</code>这条指令）</p>
<p><strong>2、字段的解析</strong><br>假设解析成功后，字段所属的类是C。</p>
<ul>
<li>先看C是否含有与目标相匹配的字段，有则返回此字段引用。</li>
<li>否则，递归往上查找C实现的接口，有则返回此字段引用。</li>
<li>否则，递归往上查找C的父类，有则返回此字段引用。</li>
<li>否则，报错。</li>
</ul>
<p>实际上虚拟机限制的会比较严格，如果继承的类与实现的接口，都有同样的字段，会编译不通过，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Hehe hehe = <span class="keyword">new</span> Hehe();</span><br><span class="line">        System.out.println(hehe.a); <span class="comment">//Reference to 'a' is ambiguous, both 'TestClass.a' and "TestInterface.a' match</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hehe</span> <span class="keyword">extends</span>  <span class="title">TestClass</span> <span class="keyword">implements</span> <span class="title">TestInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span>  <span class="title">TestInterface</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3、类方法解析</strong><br>假设解析成功后，方法所属的类是C。</p>
<ul>
<li>如果在C中有匹配的方法，则直接返回。</li>
<li>否则递归在父类中查找相匹配的方法。</li>
<li>否则就会报错。</li>
</ul>
<p><strong>4、接口方法解析</strong><br>假设解析成功后，方法所属的接口是C。</p>
<ul>
<li>如果在C中有匹配的方法，则直接返回。</li>
<li>否则递归在父接口中查找相匹配的方法。</li>
<li>否则就会报错。</li>
</ul>
<center> <h4><font color="#36648B">✎✎✎<br>初始化</font></h4></center><br>编译器可以为接口生成<code>&lt;clinit&gt;()</code>类构造器。其实初始化阶段就是执行<code>&lt;clinit&gt;()</code>方法的过程。<br>&gt; <code>&lt;init&gt;()</code>是实例构造器。<br><br>静态块语句只能访问到定义在静态块语句之前的变量，但是可以给之前的变量赋值。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        i = <span class="number">0</span>; <span class="comment">//赋值可以编译通过</span></span><br><span class="line">        System.out.println(i);  <span class="comment">//访问则编译不通过 illegal forward reference</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><code>&lt;clinit&gt;()</code>在多线程情况下只会被调用一次。<br><br>bootstrap classloader只会加载虚拟机识别的文件，若随便放个自定义的jar文件到对应目录下，bootstrap classloader也不会去加载。<br><br><br><center> <h4><font color="#36648B">✎✎✎<br>双亲委托模型</font></h4></center>

<p><strong>破坏双亲委托模型的办法</strong>：</p>
<ul>
<li><p>重写loadClass()方法。（不建议使用）</p>
<blockquote>
<p>loadClass()的大致逻辑就是：若父类加载器加载失败，则调用findClass()方法。所以我们自定义类加载器的时候，都是重写findClass()方法以符合双亲委托模型。</p>
</blockquote>
</li>
<li><p>指定线程上下文类加载器。</p>
</li>
<li>OSGI实现的模块化热部署。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/深入理解Java虚拟机_03_垃圾收集器与内存分配策略/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/26/深入理解Java虚拟机_03_垃圾收集器与内存分配策略/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">03 | 垃圾收集器与内存分配策略</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-26 00:11:49" itemprop="dateCreated datePublished" datetime="2019-11-26T00:11:49+08:00">2019-11-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/深入理解Java虚拟机/" itemprop="url" rel="index"><span itemprop="name">深入理解Java虚拟机</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><center> <h4><font color="#36648B">✎<br>对象的死亡</font></h4></center><br><strong>1、引用计数法</strong><br>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，引用失效时，计数器值就减1。任何时刻计数器为0的对象就是不可能再被使用的。<br>但是引用计数法解决不了<strong>相互循环引用</strong>的问题。</p>
<p><strong>2、可达性分析算法</strong><br>这个算法就是以一系列的<strong>GC Root</strong>为起点，从这些节点向下搜索，当一个对象不可达时，则认为这个对象“已死”。</p>
<p>GC Root包括以下4种对象：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
</ul>
<p><strong>3、引用的分类</strong><br>引用由强到若可以分为4种引用：</p>
<ul>
<li>强引用。这个就是我们平常代码里面new的引用类型。</li>
<li>软引用。可用<code>SoftReference</code>类实现软引用。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行<strong>第二次回收</strong>。如果这次回收还没有足够的内存才会抛出内存溢出异常。</li>
<li><p>弱引用。可用<code>WeakReference</code>类实现弱引用。被弱引用关联的对象只能生存到<strong>下一次垃圾收集发生之前</strong>。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p>
<blockquote>
<p>看起来不可达（死亡）对象和弱引用的生存时间是一样的？</p>
</blockquote>
</li>
<li><p>虚引用。可用<code>PhantomReference</code>实现虚引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时<strong>收到一个系统通知</strong>。</p>
</li>
</ul>
<p><strong>4、对象被回收的过程</strong></p>
<ul>
<li>可达性分析算法标志这个对象不可达（第一次标记）。</li>
<li>若对象覆盖了<code>finalize()</code>方法并且之前没有执行过这个方法，那么将这个对象放到F-Queue队列中，让Finalizer线程去执行它的<code>finalize()</code>方法。否则直接被回收。（对象的<code>finalize()</code>只可能被调用一次）</li>
<li>稍后GC会对F-Queue队列的对象进行筛选，若依旧不可达，则将会被回收。</li>
</ul>
<blockquote>
<p>可在<code>finalize()</code>方法中对这个对象进行“拯救”，即重新关联这个对象，让这个对象可达。</p>
</blockquote>
<p><strong>5、Class的回收</strong><br>可用<code>-Xnoclassgc</code>控制JVM是否对Class对象进行回收。</p>
<p><center> <h4><font color="#36648B">✎✎<br>HotSpot的算法实现</font></h4></center><br><strong>1、枚举根节点</strong></p>
<p>HotSpot使用的是准确GC，使用一组称为<strong>OopMap的数据结构</strong>存储使用到的<strong>引用以及引用的有效范围</strong>。在枚举根节点时，只需要关注OopMap的信息即可。</p>
<p><strong>2、安全点</strong></p>
<p>程序执行过程中只有处于安全点时才会停下来进行GC。所以安全点与安全点之间如果存在了非常多的指令变化内容，JVM不必为这些指令都生成oopMap，只需要在第二个安全点之前，生成一个oopMap即可。</p>
<p>另外，让程序在到达安全点时“停下来”等待GC有两种方案：</p>
<ul>
<li><p><strong>抢先式中断</strong>。GC直接让所有线程都中断，如果线程不在安全点上，则恢复它让它跑到安全点上再中断。</p>
</li>
<li><p><strong>主动式中断</strong>。线程到达一个安全点时，轮询一个标志，看是否需要GC，如果需要，就主动中断挂起。</p>
</li>
</ul>
<p>现在的JVM基本上都是使用主动式中断策略。</p>
<blockquote>
<p>从上面的信息可知，程序每到一个安全点必然会经过GC。（因为到了安全点就需要轮询）但是这样的话效率不会很低吗？</p>
</blockquote>
<p><strong>3、安全区域</strong></p>
<p>如果线程处于“不执行”的状态时，比如说处于Sleep、Blocked状态。那么就永远也跑不到安全点上了。JVM不可能为了等待这些线程跑到安全点上而不进行GC。所以就需要<strong>安全区域</strong>来解决。安全区域是指在一段代码片段之中，引用不会发生任何变化。</p>
<p>当程序执行到安全区域时，会标识自己已经进入了安全区域，若此时JVM要发起GC时，就会忽略这个线程。当线程要离开安全区域时，要检查JVM是否完成了根节点枚举，如果没有完成，则要接收到“可以离开安全区域”的信号后，程序才会往下执行。</p>
<p><center> <h4><font color="#36648B">✎✎✎<br>垃圾收集器</font></h4></center><br>|       名称        |   算法    | 是否并发 | 是否并行 | 是否需要STW | 作用区域 |<br>| :—————: | :——-: | :——: | :——: | :———: | :——: |<br>|      Serial       |   复制    |    否    |    否    |     是      |  新生代  |<br>|    Serial Old     | 标记-整理 |    否    |    否    |     是      |  老年代  |<br>|      ParNew       |   复制    |    是    |    否    |     是      |  新生代  |<br>| Parallel Scavenge |   复制    |    是    |    否    |     是       |  新生代  |<br>|   Parallel Old    | 标记-整理 |    是    |    否    |     是        |  老年代  |<br>|        CMS        | 标记-清除 |    是    | 不完全是 |     是        |  老年代  |</p>
<p><strong>1、Serial收集器</strong><br>虚拟机在Client模式下的默认新生代收集器。</p>
<p><strong>2、ParNew收集器</strong><br>Serial收集器的多线程版本。</p>
<p><strong>3、Serial Old收集器</strong><br>CMS收集器的后备预案。<br>可与Parallel Scavenge收集器组合。（已经比较少用）</p>
<p><strong>4、Parallel Scavenge收集器</strong><br>关注点在总的吞吐量。<br>适用不需要太多交互的用户。<br>一般来说GC的频率较低，所以每次GC导致的用户停顿时间会变长（频率低的话每次GC时新生代的内存空间就会比较大）。  </p>
<p><strong>5、Parallel Old收集器</strong><br>Parallel Scavenge收集器的老年代版本。</p>
<p><strong>6、CMS</strong><br>只有ParNew/Serial收集器可以与CMS收集器配合工作。<br>Serial Old收集器可作为CMS收集器的后备预案。</p>
<p><strong>收集过程：</strong></p>
<ul>
<li>初始标记。标记GC Roots能直接关联到的对象。需要STW。</li>
<li>并发标记。进行GC Roots Tracing的过程。</li>
<li>重新标记。修正并发标记期间由于用户程序继续运行而导致标记产生变化的那一部分对象的标记记录。</li>
<li>并发清除。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>需要大量CPU资源。</li>
<li>无法处理浮动垃圾。在并发清除阶段，产生的新的垃圾称为浮动垃圾，这部分垃圾只能等待下次GC清除。同时，因为并发手机时，用户程序还能继续运行，所以老年代要预留空间（预留空间的阈值是可以设置的）给用户程序，如果预留的空间不足以供用户程序运行，那么就会导致“Concurrent Mode Failure”失败。这时虚拟机就会启动后备方案：临时启用Serial Old收集器来对老年代进行垃圾回收。</li>
<li>由标记-清除算法带来的问题：内存碎片。也可以设置执行了多少次不进行压缩的full gc后，进行一次压缩。</li>
</ul>
<p><strong>7、G1收集器</strong><br>特点：</p>
<ul>
<li>并行与并发。</li>
<li>分代收集。</li>
<li>空间整合。整体上来看是使用标记-整理算法，局部上来说其实是使用了复制算法。</li>
<li>可预测的停顿。指定在M毫秒的时间段内，消耗的垃圾回收时间不会超过N毫秒。</li>
</ul>
<p>G1会优先回收<strong>价值最大</strong>的Region。</p>
<p>老年代与新生代不再是物理隔离的。整个堆被分为N个Region。每个Region都有一个Remembered Set，记录其对其他Region的引用。</p>
<p>收集过程：</p>
<ul>
<li>初始标记。</li>
<li>并发标记。</li>
<li>最终标记。</li>
<li>筛选回收。</li>
</ul>
<p><strong>8、java默认垃圾回收器</strong></p>
<ul>
<li>jdk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）。</li>
<li>jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）。</li>
<li>jdk1.9 默认垃圾收集器G1。</li>
<li>jdk10 默认垃圾收集器G1。</li>
<li>jdk11 默认垃圾收集器G1。</li>
</ul>
<p><center> <h4><font color="#36648B">✎✎✎✎<br>内存分配</font></h4></center><br>一般来说，Full GC前都会经过Minor GC，但并非绝对，在Parallel Scavenge收集策略里就有直接进行Full GC的策略。<br>Full GC的速度一般会比Minor GC慢10倍以上。</p>
<p><strong>1、直接进入老年代的大对象</strong><br>设置<code>-XX:PretenureSizeThreshold</code>这个参数在分配内存空间时可令大于它的对象直接进入老年代。</p>
<blockquote>
<p>这个参数只对Serial和ParNew两款收集器有效。</p>
</blockquote>
<p><strong>2、新生代对象何时进入老年代</strong></p>
<ul>
<li>存活年龄达到阈值。</li>
<li>在Sirvivor空间中相同年龄所有对象大小的总和大与Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</li>
</ul>
<p><strong>3、空间分配担保</strong><br>JDK 6 Update 24后，当新生代将要进行Minor GC时，JVM会对老年代进行以下检查：</p>
<ul>
<li>老年代的连续空间是否大于新生代对象总大小。</li>
<li>老年代的连续空间是否大于历次晋升的平均大小。</li>
</ul>
<p>如果满足上述其中一条，就会走正常的对象转移流程。（Minor GC - &gt; Full GC）<br>如果都不满足，则会先Full GC再进行Minor GC后再Full GC。</p>
<blockquote>
<p>需要注意的是第一个流程有可能不需要进行Full GC（在To 空间有足够内存存放新生代存活对象的时候）<br>不明白为什么要改成这样子，如果走第二种流程的话感觉先Full GC没有什么意义。</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/24/深入理解Java虚拟机_02_Java内存区域与内存溢出异常/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/24/深入理解Java虚拟机_02_Java内存区域与内存溢出异常/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">02 | Java内存区域与内存溢出异常</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-24 21:58:59" itemprop="dateCreated datePublished" datetime="2019-11-24T21:58:59+08:00">2019-11-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/深入理解Java虚拟机/" itemprop="url" rel="index"><span itemprop="name">深入理解Java虚拟机</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><center> <h4><font color="#36648B">✎<br>程序计数器</font></h4></center><br>程序计数器是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<p>每一个线程都会有一个独立的程序计数器。</p>
<p><center> <h4><font color="#36648B">✎✎<br>栈</font></h4></center><br>每个方法在执行的同时都会创立一个<strong>栈帧</strong>。</p>
<p>在oom时存储快照的参数：<code>-XX:+HeapDumpOnOutOfMemoryError</code>。</p>
<p>指定栈内存大小参数：<code>-Xss</code>(默认为512k)</p>
<p>抛出<strong>StackOverflowError</strong> 是因为栈内存不够，而不是栈深度到了指定的深度。</p>
<p>同一个类，如果被不同的类加载器加载两次，那么在栈中也就会存在两份Class对象。</p>
<p><center> <h4><font color="#36648B">✎✎✎<br>常量池</font></h4></center><br>jdk1.6中，String的<code>intern()</code>方法会把“<strong>首次遇到</strong>”的字符串实例复制到常量池中，并返回这个实例引用。<br>而在jdk1.7中，不再复制实例，而是记录这个实例的引用。(也就是说把实例放到了堆中)</p>
<p>demo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String str =  <span class="keyword">new</span> StringBuilder(<span class="string">"A"</span>).toString();</span><br><span class="line">        System.out.println(str.intern() == str);  <span class="comment">//false 非常量池的对象</span></span><br><span class="line"></span><br><span class="line">        String str2 =  <span class="keyword">new</span> StringBuilder(<span class="string">"B"</span>).append(<span class="string">"C"</span>).toString();</span><br><span class="line">        System.out.println(str4.intern() == str4);<span class="comment">//true 为常量池对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子有点意思，在编译期间A、B、C就已经放入常量池了，所以新建值为A的实例与常量池值为A的实例肯定不同。而常量池没有值为BC的实例，所以当执行itern()方法时，自然就会把新建的“BC”实例给“放入”常量池，所以两只的引用指向的是同一个实例。</p>
<blockquote>
<p>str.itern()与str = “”这种方式赋值的区别是？<br>如果大量使用intern或者 str = “”这种写法，是不是会容易造成OOM？<br>常量是否也会被回收？</p>
</blockquote>
<p><center> <h4><font color="#36648B">✎✎✎✎<br>堆</font></h4></center><br><strong>1、创建对象时，分配内存的方式有如下两种：</strong></p>
<ul>
<li>如果内存是绝对规整的，就直接使用“<strong>指针碰撞</strong>”。（如果使用复制或带有压缩功能的算法，那么内存就是绝对规整的）</li>
<li>否则就使用“<strong>空闲列表</strong>”的方式，在一个列表中维护各个可用的内存块。需要时则直接在列表找到符合条件的内存块。</li>
</ul>
<p><strong>2、在并发的情况下对分配内存的正确结果的保证有如下两种方式：</strong></p>
<ul>
<li>采用CAS配上失败重试的方式。</li>
<li>给每个线程分配一小块内存（<strong>TLAB</strong>），若这小块内存不够用时，再<strong>同步申请</strong>新的TLAB。（是否使用这种方式可以由 -XX:+/-UseTLAB）</li>
</ul>
<p><strong>3、内存中的实例对象包含以下3种数据</strong></p>
<ul>
<li>对象头。</li>
<li>实例数据。</li>
<li>对齐填充。</li>
</ul>
<p><center> <h4><font color="#36648B">✎✎✎✎✎<br>对象的访问定位</font></h4></center><br>对象的访问定位有以下两种方式</p>
<ul>
<li><strong>直接访问</strong>。优点是访问速度快。</li>
<li><strong>使用句柄间接访问</strong>。优点是对象被移动时，只需要移动句柄，不需要动原来对象。</li>
</ul>
<p><center> <h4><font color="#36648B">✎✎✎✎✎✎<br>直接内存</font></h4></center><br>Nio直接请求分配了<strong>堆外内存</strong>（也就是直接内存），<strong>避免了在Java堆和Native堆中来回复制数据</strong>。<br>直接内存容量可通过<code>-XX:MaxDirectMemorySize</code>指定，如果不指定，则<strong>默认与Java堆最大值</strong>（-Xmx指定）一样。<br>可通过反射获取<code>UnSafe</code>实例分配直接内存。</p>
<blockquote>
<p>Unsafe类的<code>getUnsafe()</code>方法限制了只有引导类加载器才会返回实例。所以只能用反射的方式去使用Unsafe。</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/22/动态代理剖析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/22/动态代理剖析/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">动态代理剖析</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-22 21:54:43" itemprop="dateCreated datePublished" datetime="2019-11-22T21:54:43+08:00">2019-11-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/个人分享/" itemprop="url" rel="index"><span itemprop="name">个人分享</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/个人分享/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/个人分享/Java/动态代理/" itemprop="url" rel="index"><span itemprop="name">动态代理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>sun.misc.ProxyGenerator.saveGeneratedFiles  设置这个参数为true可让java动态代理类生成.class文件</p>
<p>Object的方法中，除了hashCode,equals,tosString这三个方法会被代理，其他方法都不会被代理。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/12/深入理解JVM[课程]_09_Java字节码/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/12/深入理解JVM[课程]_09_Java字节码/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">09 | Java字节码</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-12 12:22:00" itemprop="dateCreated datePublished" datetime="2019-11-12T12:22:00+08:00">2019-11-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-03-16 20:32:21" itemprop="dateModified" datetime="2020-03-16T20:32:21+08:00">2020-03-16</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/深入理解JVM-课程/" itemprop="url" rel="index"><span itemprop="name">深入理解JVM[课程]</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <center> <h4><font color="#36648B">✎<br>字节码文件结构</font></h4></center>

<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">所占空间(字节)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Magic Number</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">Version</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">Constant Pool</td>
<td style="text-align:center">2+n</td>
</tr>
<tr>
<td style="text-align:center">Access Flags</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">This Class Name</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">Super Class Name</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">Interfaces</td>
<td style="text-align:center">2+n</td>
</tr>
<tr>
<td style="text-align:center">Fields</td>
<td style="text-align:center">2+n</td>
</tr>
<tr>
<td style="text-align:center">Methods</td>
<td style="text-align:center">2+n</td>
</tr>
<tr>
<td style="text-align:center">Attributes</td>
<td style="text-align:center">2+n</td>
</tr>
</tbody>
</table>
<blockquote>
<p>每个类的常量池都有许多值相同的常量，那么这些常量是共享的吗？类的常量池和我们平常所说的常量池有什么区别？</p>
</blockquote>
<p><center> <h4><font color="#36648B">✎✎<br>方法</font></h4></center><br>对于Java类中的每一个<strong>实例方法</strong>（非static方法），其在编译后所生成的字节码当中，方法参数的数量总是会比源代码中方法参数的数量多一个（<strong>this</strong>），它位于方法的第一个参数位置处。</p>
<blockquote>
<p>入参一定会存放到局部变量表中。</p>
</blockquote>
<p><center> <h4><font color="#36648B">✎✎✎<br>异常</font></h4></center><br>假设方法中有<code>try catch</code>的语法，那么在<strong>运行时</strong>局部变量表会多一个记录异常的变量。</p>
<p><strong>1、JVM对异常的处理方式</strong></p>
<ul>
<li>采用<strong>异常表</strong>的方式来对异常进行处理。</li>
<li>当异常处理存在<code>finally</code>语句块时，现代化的JVM采取的处理方式是将finally语句块的字节码拼接到每一个catch块后面，换句话说，程序中存在多少个catch块，就会在每一个catch块后面重复多少个finally语句块的字节码。</li>
</ul>
<p><center> <h4><font color="#36648B">✎✎✎✎<br>栈帧（stack frame）</font></h4></center><br>栈帧是一种用于帮助虚拟机执行方法调用与方法执行的数据结构,封装了方法的局部变量表、动态链接信息、方法的返回地址以及操作数栈等信息。</p>
<p>有些符号引用是在类加载阶段或是第一次使用时就会转换为直接引用，这种转换叫做静态解析；另外一些符号引用则是在每次运行期转换为直接引用，这种转换叫做动态链接，这体现为Java的多态性。</p>
<p><center> <h4><font color="#36648B">✎✎✎✎✎<br>方法调用</font></h4></center></p>
<ul>
<li><strong>invokeinterface</strong>：调用接口中的方法，实际上是在运行期决定的，决定到底调用实现该接口的哪个对象的特定方法。</li>
<li><strong>invokestatic</strong>：调用静态方法。</li>
<li><strong>invokespecial</strong>：调用自己的私有方法、构造方法以及父类的方法。</li>
<li><strong>invokevirtual</strong>：调用虚方法，运行期动态查找的过程。</li>
<li><strong>invokedynamic</strong>：动态调用方法。</li>
</ul>
<p><center> <h4><font color="#36648B">✎✎✎✎✎<br>静态解析与动态链接</font></h4></center><br><strong>1、静态解析的4种情形</strong></p>
<ul>
<li>静态方法</li>
<li>父类方法</li>
<li>构造方法</li>
<li>私有方法（无法被重写）</li>
</ul>
<p>以上4类方法称作非虚方法，他们是在类加载阶段就可以<strong>将符号引用转换为直接引用</strong>的。</p>
<blockquote>
<p>公有方法有可能被重写，所以不能被静态解析。</p>
</blockquote>
<p><strong>2、方法的静态分派Demo</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Grandpa grandpa)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Grandpa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Father father)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Father"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Son son)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Grandpa g1 = <span class="keyword">new</span> Father();</span><br><span class="line">        Grandpa g2 = <span class="keyword">new</span> Son();</span><br><span class="line">        Test6 test6 = <span class="keyword">new</span> Test6();</span><br><span class="line">        test6.test(g1); <span class="comment">//输出Grandpa</span></span><br><span class="line">        test6.test(g2); <span class="comment">//输出Grandpa</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Grandpa</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码，g1的<strong>静态类型是</strong>Grandpa，而g1的实际类型（真正指向的类型）是Father。<br>变量的静态类型是<strong>不会发生变化</strong>的，而变量的实际类型则是可以发生变化的（多态的一种体现），实际类型是在运行期方可确定。<br><strong>方法重载，是一种静态的行为</strong>，编译期就可以完全确定。</p>
<p><strong>3、方法动态分派Demo</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fruit f1 = <span class="keyword">new</span> Apple();</span><br><span class="line">        Fruit f2 = <span class="keyword">new</span> Banana();</span><br><span class="line">        f1.test(); <span class="comment">//输出Apple</span></span><br><span class="line">        f2.test(); <span class="comment">//输出Banana</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Fruit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Apple"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Banana"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>方法重写是一种动态的行为</strong>，在运行期才可以决定。</p>
<blockquote>
<p>总的来说就是：<br>调用哪个方法（重载导致有多个同名方法），是由所传入的引用类型决定的。<br>确定完调用方法之后，再去寻找调用这个方法的实例，这是由实际类型所决定的。</p>
</blockquote>
<p><center> <h4><font color="#36648B">✎✎✎✎✎✎<br>操作数栈</font></h4></center><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> max = a+b+c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上代码显示了一个很简单的相加运算，用jclasslib打开它的.class文件，展示的字节码逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0 iconst_1</span><br><span class="line">1 istore_1</span><br><span class="line">2 iconst_2</span><br><span class="line">3 istore_2</span><br><span class="line">4 iconst_3</span><br><span class="line">5 istore_3</span><br><span class="line">6 iload_1</span><br><span class="line">7 iload_2</span><br><span class="line">8 iadd</span><br><span class="line">9 iload_3</span><br><span class="line">10 iadd</span><br><span class="line">11 istore 4</span><br><span class="line">13 return</span><br></pre></td></tr></table></figure>
<p>iconst_1表示将1入栈，istore_1表示将栈顶元素存储到局部变量表index为1的地方，以此类推。<br>iload_1表示读取局部变量表index为1的变量，压入栈。<br>iadd表示连续两次将栈顶弹出，并将弹出的元素相加，得出的结果压入栈。<br>istore 4表示将栈顶元素赋值给局部变量表中index为4的变量。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/05/Kafka权威指南_06_可靠的数据传输/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/05/Kafka权威指南_06_可靠的数据传输/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">06 | 可靠的数据传输</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-05 19:56:24" itemprop="dateCreated datePublished" datetime="2019-11-05T19:56:24+08:00">2019-11-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Kafka/Kafka权威指南/" itemprop="url" rel="index"><span itemprop="name">Kafka权威指南</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎broker层面的保证"><a href="#✎broker层面的保证" class="headerlink" title="✎broker层面的保证"></a><center><font color="#36648B">✎</font><br><font color="#36648B">broker层面的保证</font></center></h4><ul>
<li>kafka可以保证分区内消息的一致性。</li>
<li>消费者接收到的消息，一定是已经被写入分区的所有同步副本的。</li>
<li>设置副本进行数据备份，防止数据丢失。</li>
</ul>
<h4 id="✎生产者层面的保证"><a href="#✎生产者层面的保证" class="headerlink" title="✎生产者层面的保证"></a><center><font color="#36648B">✎</font><br><font color="#36648B">生产者层面的保证</font></center></h4>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/31/深入理解JVM[课程]_08_类的卸载/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/31/深入理解JVM[课程]_08_类的卸载/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">08 | 类的卸载</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-31 23:32:04" itemprop="dateCreated datePublished" datetime="2019-10-31T23:32:04+08:00">2019-10-31</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/深入理解JVM-课程/" itemprop="url" rel="index"><span itemprop="name">深入理解JVM[课程]</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎相关概念与定义"><a href="#✎相关概念与定义" class="headerlink" title="✎相关概念与定义"></a><center><font color="#36648B">✎</font><br><font color="#36648B">相关概念与定义</font></center></h4><p>当T类被加载、连接和初始化后，它的生命周期就开始了。当代表T类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，T类<strong>在方法区内的数据也会被卸载</strong>，从而结束T类的生命周期。</p>
<h4 id="✎✎Class对象被引用的地方"><a href="#✎✎Class对象被引用的地方" class="headerlink" title="✎✎Class对象被引用的地方"></a><center><font color="#36648B">✎✎</font><br><font color="#36648B">Class对象被引用的地方</font></center></h4><ul>
<li>类加载器与它所加载的类是双向关联的关系。</li>
<li>一个类的实例总是会引用代表这个类的Class对象。<blockquote>
<p><strong>问题1</strong>双向关联的话，不就一直都不会被垃圾回收了吗？</p>
</blockquote>
</li>
</ul>
<p>从上可知，要使一个class对象结束生命周期，它的<strong>类加载器实例</strong>与它的<strong>对象实例</strong>均要被垃圾回收。</p>
<p>由Java虚拟机自带的类加载器（根类加载器、扩展类加载器和系统类加载器）所加载的类，在虚拟机的生命周期中，<strong>始终不会被卸载</strong>。因为<strong>Java虚拟机本身会始终引用这些类加载器</strong>。</p>
<h4 id="✎✎✎观察类的卸载信息"><a href="#✎✎✎观察类的卸载信息" class="headerlink" title="✎✎✎观察类的卸载信息"></a><center><font color="#36648B">✎✎✎</font><br><font color="#36648B">观察类的卸载信息</font></center></h4><ul>
<li>通过<code>jvisualvm</code>弹出可视化的窗口，在“监视”栏可看到类的卸载总数与加载总数。</li>
<li>使用<code>-XX:+TraceClassLoading</code>参数打印类的加载信息。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/26/深入理解JVM[课程]_07_类的实例化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/26/深入理解JVM[课程]_07_类的实例化/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">07 | 类的实例化</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-26 13:19:55" itemprop="dateCreated datePublished" datetime="2019-10-26T13:19:55+08:00">2019-10-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/深入理解JVM-课程/" itemprop="url" rel="index"><span itemprop="name">深入理解JVM[课程]</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎实例化的步骤"><a href="#✎实例化的步骤" class="headerlink" title="✎实例化的步骤"></a><center><font color="#36648B">✎</font><br><font color="#36648B">实例化的步骤</font></center></h4><ul>
<li>为新的对象分配内存。</li>
<li>为实例变量赋默认值。</li>
<li>为实例变量赋正确的初始值。<blockquote>
<p>通过字节码得出，为实例变量赋初始值是在构造方法中完成的。在调用父类构造方法之后，在执行构造方法代码逻辑之前。</p>
</blockquote>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/23/深入理解JVM[课程]_06_接口/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/23/深入理解JVM[课程]_06_接口/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">06 | 接口</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-23 23:32:45" itemprop="dateCreated datePublished" datetime="2019-10-23T23:32:45+08:00">2019-10-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/深入理解JVM-课程/" itemprop="url" rel="index"><span itemprop="name">深入理解JVM[课程]</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>interface中的变量默认就是<code>public static final</code>,其实它的初始化过程与class是大体上一样的。 </p>
<p>一个父接口并不会因为它的子接口或者实现类的初始化而初始化。</p>
<blockquote>
<p>通过JDK1.8代码验证得出:<br>子接口初始化了，父接口会被加载但是不会被初始化。<br>实现类初始化了，接口会被加载但是不会被初始化。</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">aFightz</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">98</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">35</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aFightz</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  


  
  

  

  

  

  

  

  

</body>
</html>
