<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="aFightz">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="aFightz">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="aFightz">






  <link rel="canonical" href="http://yoursite.com/page/3/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>aFightz</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">aFightz</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/22/Kafka权威指南_05_深入Kafka/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/22/Kafka权威指南_05_深入Kafka/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">05 | 深入Kafka</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-22 19:42:45" itemprop="dateCreated datePublished" datetime="2019-10-22T19:42:45+08:00">2019-10-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Kafka/Kafka权威指南/" itemprop="url" rel="index"><span itemprop="name">Kafka权威指南</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎集群成员关系"><a href="#✎集群成员关系" class="headerlink" title="✎集群成员关系"></a><center><font color="#36648B">✎</font><br><font color="#36648B">集群成员关系</font></center></h4><p>broker启动的时候会在创建一个<strong>临时节点</strong>，把自己的id注册到zk上（<code>/brokers/ids/#</code>这样的形式）。Kafka组件会监听<code>/brokers/ids</code>这个路径，当集群中有broker退出或新增时，组件都会知悉。<br>将一个broker完全关闭之后，启动另外一个拥有相同id的broker，那么它会拥有与旧broker相同的分区与主题。</p>
<h4 id="✎✎控制器"><a href="#✎✎控制器" class="headerlink" title="✎✎控制器"></a><center><font color="#36648B">✎✎</font><br><font color="#36648B">控制器</font></center></h4><p>集群中的broker在加入集群时，都会尝试创建临时节点<code>/controller</code>，但是只有一个可以创建成功，那么它将成为控制器。其他竞争失败的broker将会监听这个临时节点，以便当节点变更时（比如说控制器挂了），它们可以知悉。当控制器挂了，剩余的broker又会开始竞争流程。<br>新的broker在成为控制器后，通过zk的递增操作获得数值更大的epoch。其他broker会忽略掉比当前epoch小的消息（这些消息也就是从旧的控制器发出的），从而避免了“脑裂”。</p>
<blockquote>
<p>如果控制器在断开后重连，当发现创建<code>/controller</code>失败后，它应该就知道自己不是控制器了，那么之前比较小的epoch又是怎么发出的呢？</p>
</blockquote>
<p>当控制器发现若一个broker离开后(通过监听<code>/brokers/ids</code>这个节点可知)，若这个broker又是分区leader，那么控制器就会在剩余的分区副本列表里面选出一个leader，并通知副本列表。</p>
<h4 id="✎✎✎复制"><a href="#✎✎✎复制" class="headerlink" title="✎✎✎复制"></a><center><font color="#36648B">✎✎✎</font><br><font color="#36648B">复制</font></center></h4><p>如果Follower在一定时间内（这个时间由<code>replica.Lag.time.max.ms</code>配置，默认为10S）没有向Leader请求同步数据，或者在一定时间内（默认是6S）没有向zk发送心跳消息，那么这个Follower就被认为是<strong>不同步</strong>的，当分区Leader失去连接触发重新选举时，<strong>未同步的Follower将不会被选举</strong>。</p>
<p>每一个分区都有一个<strong>首选Leader</strong>，它由以下两种方式指定：</p>
<ul>
<li><strong>创建主题时选定的Leader分区</strong>就是首选Leader。</li>
<li>手动进行副本分配，<strong>第一个指定的副本</strong>就是首选Leader。</li>
</ul>
<p>当<code>auto.leader.rebalance.enable</code>设为true时，它会去检查首选Leader是不是当前Leader，如果不是，且首选Leader是同步的那么就会触发选举，<strong>让首选Leader成为当前Leader</strong>。</p>
<p>在复制还未完成的时候，如果此时leader崩溃，那么就会导致数据丢失。</p>
<p>若一个同步副本滞后，会使生产者与消费者变慢。副本滞后则意味着副本肯定不会同步最新的消息，因为同步也是按消息顺序来的。若生产者若设置了ack = all，那么它会一直等待此消息被副本同步，而生产者也只会消费被同步了的消息。<br>滞后的原因会有两个：</p>
<ul>
<li>副本崩溃且没有重启，在经过指定时间后，leader就不会再等待它同步了。</li>
<li>副本崩溃在一定时间后重启了，此时若崩溃的时间过长，有大量的数据没有被同步，此时生产者与消费者在此副本同步完之前皆会被“卡”住。<blockquote>
<p>临时增加分区应该也有同步副本滞后的效果。<br>这个要怎么解决？</p>
</blockquote>
</li>
</ul>
<h4 id="✎✎✎✎请求"><a href="#✎✎✎✎请求" class="headerlink" title="✎✎✎✎请求"></a><center><font color="#36648B">✎✎✎✎</font><br><font color="#36648B">请求</font></center></h4><p><strong>1、Kafka处理请求的内部流程</strong><br><img src="/2019/10/22/Kafka权威指南_05_深入Kafka/kafka处理请求的内部流程.png" alt=""><br>broker会在它所监听的每一个端口上运行一个<strong>Acceptor线程</strong>，这个线程会创建一个连接，并把它交给<strong>Processor线程</strong>去处理。Processor线程的数量是可配置的。Processor线程把客户端请求的消息放进请求队列，然后从响应队列获取响应消息，把它们发送给客户端。</p>
<p><strong>2、客户端获取分区leader所在的broker的过程</strong><br><img src="/2019/10/22/Kafka权威指南_05_深入Kafka/客户端获取分区leader所在的broker的过程.png" alt=""><br>客户端对<strong>任意broker</strong>（因为每个broker都缓存了这部分数据）发送<strong>元数据请求</strong>，然后将返回的数据（包括表明分区leader在哪个broker的信息）缓存起来，之后需要间隔一定的时间去重新缓存这部分数据（时间间隔可以由<code>metadata.max.age.ms</code>来配置）。</p>
<p>当客户端将数据发送到一个不是分区leader的broker的时候，会接收到一个“<strong>非分区首领</strong>”的错误，然后客户端会重新缓存元数据，再重新发送数据到相应的Borker。</p>
<p><strong>3、生产请求</strong><br>如果<code>acks=0</code>，那么生产者在把消息发出去之后，完全<strong>不需要等待broker的响应</strong>。<br>在消息被写入分区的首领之后，broker开始检查acks配置参数</p>
<ul>
<li>如果acks被设为0或1，那么broker立即返回响应。</li>
<li>如果acks被设为all，那么请求会被保存在一个叫作<strong>炼狱</strong>的缓冲区里，直到首领发现所有跟随者副本都复制了消息，响应才会被返回给客户端。</li>
</ul>
<p><strong>4、获取请求</strong><br>Kafka使用<strong>零复制技术</strong>向客户端发送消息。<br><strong>零复制技术</strong>的意思就是直接把消息从文件（或者更确切地说是Linux文件系统缓存）里发送到网络通道，而不需要经过任何中间缓冲区。这项技术避免了字节复制，也不需要管理内存缓冲区，从而获得更好的性能。</p>
<h4 id="✎✎✎✎✎物理存储"><a href="#✎✎✎✎✎物理存储" class="headerlink" title="✎✎✎✎✎物理存储"></a><center><font color="#36648B">✎✎✎✎✎</font><br><font color="#36648B">物理存储</font></center></h4><p><strong>1、集群中分区的分配规则</strong><br>假设有5个broker（broker0 ~ broker4），5个分区（分区0 ~ 分区4），每个分区有3个副本。</p>
<ul>
<li><p>若没有配置机架信息。首先会随机选择一个broker，假设选择了broker3，那么分区0首领副本会被分在broker3，分区1首领副本会被分在broker4，依次类推。首领副本分完之后，再分配跟随者副本，分区1的第一个跟随者副本会被分配在broker4上，第二个跟随者副本会被分配在broker0。以此类推。</p>
</li>
<li><p>若配置了机架的信息，那么broker就根据机架信息分组。选择的顺序会是机架A、机架B……以此类推。</p>
</li>
</ul>
<p><strong>2、broker内分区的分配规则</strong><br><code>log.dirs</code>指定了分区目录（可多个）<br>计算每个目录的分区数量，新的分区总是被添加到数量最小的那个目录里。</p>
<p><strong>3、文件管理</strong><br>broker会为分区里的每个片段打开一个文件句柄，哪怕片段是不活跃的。这样会导致打开过多的文件句柄，所以操作系统必须根据实际情况做一些调优。</p>
<p><strong>4、文件格式</strong><br>保存在磁盘上的数据格式与从生产者发送过来或者发送给消费者的消息格式是一样的。<br>使用了压缩算法后，同一批次的消息会被压缩到一起。<br>DumpLogSegment工具可以查看片段内容。</p>
<p><strong>5、索引</strong><br>为了帮助broker更快地定位到指定的偏移量，Kafka为每个分区维护了一个索引。删除索引后，kafka会自动重新生成索引。</p>
<p><strong>6、清理重复的消息</strong><br>假设有这样一个场景，对于key相同的消息，kafka内部只需要保存最新的一条。<br>对于这种场景，可以为主题设置compact策略来实现。如果设置<code>log.cleaner.enabled</code>为true，那么kafka就会启用清理功能来实现上述场景。</p>
<blockquote>
<p>如果不启用清理功能，那么设置了compact策略似乎也没意义？</p>
</blockquote>
<p>每个Broker会启动一个清理管理器线程和多个清理线程。线程会选择污浊率较高的分区进行清理。</p>
<blockquote>
<p>污浊消息表示的是还未被清理的。<br>污浊率 = 污浊消息大小/分区大小</p>
</blockquote>
<p>线程会新建一个map，然后将污浊消息的key存入这个map中，其实也就是去重操作。清理完后就会用这个map替换原来的片段。</p>
<p>如果需要删除某个key的所有消息，则需要push一个key -&gt; null 这样的形式的消息（墓碑消息），清理线程会保留墓碑消息一段时间（这个时间可配置），消费者在监听到value为null时，作忽略处理即可。</p>
<blockquote>
<p>但是也有隐患，如果在保留的这段时间内，刚好消费者离线，那么消费者就有可能检测不到这个墓碑消息。</p>
</blockquote>
<p>compact策略也不会去清理仍在活跃的片段。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/22/深入理解JVM[课程]_05_静态常量/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/22/深入理解JVM[课程]_05_静态常量/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">05 | 静态常量</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-22 12:33:17" itemprop="dateCreated datePublished" datetime="2019-10-22T12:33:17+08:00">2019-10-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/深入理解JVM-课程/" itemprop="url" rel="index"><span itemprop="name">深入理解JVM[课程]</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎静态常量的本质含义"><a href="#✎静态常量的本质含义" class="headerlink" title="✎静态常量的本质含义"></a><center><font color="#36648B">✎</font><br><font color="#36648B">静态常量的本质含义</font></center></h4><p>静态常量在<strong>编译阶段</strong>会存入到<strong>调用这个静态常量的方法所在的类的静态常量池</strong>中，本质上，调用类并没有直接引用到定义静态常量的类，因此并<strong>不会触发定义静态常量的类的初始化</strong>。如下：</p>
<p><strong>Demo</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> parent = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"parent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**由于将静态常量存放到了Test的静态常量池中，不触发Test的初始化。所以输出：</span></span><br><span class="line"><span class="comment">         * 1</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 我们甚至可以在编译完之后将Parent.class文件删除也不会影响程序运行结果(说明不会去加载Parent，更别说去初始化了)。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(Parent.parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，当一个静态常量的值<strong>并非编译期间可以确定的</strong>，那么其值就不会被放到调用类的静态常量池中，这时在程序运行时，会主动使用这个静态常量所在的类，显然会导致这个类被初始化。将上述的Parent类改一下，如下：</p>
<p><strong>Demo</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> parent = UUID.randomUUID().toString();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"parent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Paren类将会被初始化，输出“parent”。</p>
<blockquote>
<p>同理可得，非静态常量也不是非编译期间可以确定的，所以也不会被放到调用类的常量池中。</p>
</blockquote>
<h4 id="✎✎反编译与助记符"><a href="#✎✎反编译与助记符" class="headerlink" title="✎✎反编译与助记符"></a><center><font color="#36648B">✎✎</font><br><font color="#36648B">反编译与助记符</font></center></h4><p><strong>1、反编译命令</strong><br><code>javap -c [.class path]</code></p>
<blockquote>
<p>反编译上面的Test.class文件，会发现Test的字节码文件中确实没有引用到到Parent，而是使用下述的助记符直接推静态常量。<br><code>javap -verbose</code> 能打印更详细的信息。(加上<code>-p</code>会打印private信息)</p>
</blockquote>
<p><strong>2、助记符</strong></p>
<ul>
<li><strong>ldc</strong>：表示将int，float或是string类型的静态常量值从静态常量池中推送至栈顶。</li>
<li><strong>sipush</strong>：表示格一个短整型静态常量值（-32768~32767）推送至栈顶。</li>
<li><strong>bipush</strong>：表示将单字节（-128~127）的静态常量值推送至栈顶。</li>
<li><strong>iconst_1</strong>：表示将int类型1推送至栈顶（iconst_1~iconst_5）。</li>
</ul>
<blockquote>
<p>double、char、byte类型呢？<br>是否是优先使用表示“小区间”的助记符，如果不符合再使用“大区间”的？</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/20/深入理解JVM[课程]_04_vm参数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/20/深入理解JVM[课程]_04_vm参数/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">04 | vm参数</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-20 16:19:55" itemprop="dateCreated datePublished" datetime="2019-10-20T16:19:55+08:00">2019-10-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/深入理解JVM-课程/" itemprop="url" rel="index"><span itemprop="name">深入理解JVM[课程]</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎vm参数设置方式"><a href="#✎vm参数设置方式" class="headerlink" title="✎vm参数设置方式"></a><center><font color="#36648B">✎</font><br><font color="#36648B">vm参数设置方式</font></center></h4><ul>
<li><code>-XX:+&lt;option&gt;</code>，表示开启option选项。</li>
<li><code>-XX:-&lt;option&gt;</code>，表示关闭option选项。</li>
<li><code>-XX:&lt;option&gt;=&lt;value&gt;</code>，表示格option选项的值设置为value。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/20/深入理解JVM[课程]_03_类的初始化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/20/深入理解JVM[课程]_03_类的初始化/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">03 | 类的初始化</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-20 16:19:55" itemprop="dateCreated datePublished" datetime="2019-10-20T16:19:55+08:00">2019-10-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/深入理解JVM-课程/" itemprop="url" rel="index"><span itemprop="name">深入理解JVM[课程]</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎初始化的功能"><a href="#✎初始化的功能" class="headerlink" title="✎初始化的功能"></a><center><font color="#36648B">✎</font><br><font color="#36648B">初始化的功能</font></center></h4><p>为类的<strong>静态变量</strong>赋予正确的初始值。</p>
<h4 id="✎✎初始化的时机"><a href="#✎✎初始化的时机" class="headerlink" title="✎✎初始化的时机"></a><center><font color="#36648B">✎✎</font><br><font color="#36648B">初始化的时机</font></center></h4><p>每个类或接口在被Java程序“<strong>首次主动使用</strong>”时才被初始化，首次使用分为以下7种情况：</p>
<ul>
<li>创建类的实例。</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值。</li>
<li>调用类的静态方法。</li>
<li>反射。(<code>Class.forName</code>)</li>
<li>初始化这个类的子类。</li>
<li>Java虚拟机启动时被标明为启动类的类（带有main方法的类）。</li>
<li>JDK1.7开始提供的动态语言支持：<strong>java.lang.invoke.MethodHandle</strong>实例的解析结果REF_getStatic，REF_putStatic，REF_invokeStatic句柄对应的类如果没有初始化，则初始化。</li>
</ul>
<blockquote>
<p>调用<strong>ClassLoader</strong>类的<code>loadClass</code>方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p>
</blockquote>
<p><strong>1、子类与父类初始化Demo</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> parent = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"parent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> child = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"child"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"main"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**首先会初始化main方法所在的类，之后使用到了Child的静态变量，所以Child需要被初始化，Child被初始化之前Child的父类也必须被初始化。输出：</span></span><br><span class="line"><span class="comment">         * main</span></span><br><span class="line"><span class="comment">         * parent</span></span><br><span class="line"><span class="comment">         * child</span></span><br><span class="line"><span class="comment">         * 1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(Child.child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>上述例子中的类加载顺序和类初始化顺序其实是一样的，可以通过开启VM参数去观察一下这三个类的加载顺序。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**此时没有直接使用到Child的静态变量而使用了Parent的静态变量，所以Child没有被初始化而Parent被初始化了。输出：</span></span><br><span class="line"><span class="comment">         * parent</span></span><br><span class="line"><span class="comment">         * 1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(Child.parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、反射与类加载器初始化Demo</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        ClassLoader loader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        loader.loadClass(<span class="string">"CL"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">        Class.forName(<span class="string">"CL"</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *  输出：</span></span><br><span class="line"><span class="comment">        *  -----------</span></span><br><span class="line"><span class="comment">        *  CL</span></span><br><span class="line"><span class="comment">        *  </span></span><br><span class="line"><span class="comment">        *  说明类加载器加载类不会去初始化类，而反射会去初始化类。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"CL"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="✎✎✎初始化顺序"><a href="#✎✎✎初始化顺序" class="headerlink" title="✎✎✎初始化顺序"></a><center><font color="#36648B">✎✎✎</font><br><font color="#36648B">初始化顺序</font></center></h4><p>类的初始化顺序是<strong>从上往下</strong>的，如下Demo可以说明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest6</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance(); </span><br><span class="line">        System.out.println(<span class="string">"counter1: "</span>+Singleton.counter1);</span><br><span class="line">        System.out.printin(<span class="string">"counter2: "</span>+Singleton.counter2);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *  输出的结果是:</span></span><br><span class="line"><span class="comment">        *  1</span></span><br><span class="line"><span class="comment">        *  0</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter1; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton(); </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        counter1++;</span><br><span class="line">        counter2++;      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter2 = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当singleton类被加载完连接完后，counter1与counter2都被赋为了0，Singleton被赋为了null，此时的调用getInstance()这个静态方法（主动使用），Singleton将被初始化，从上往下赋值：</p>
<ul>
<li>singleton变量被赋值，触发构造方法Singleton()，此时counter1为1，counter2为1。</li>
<li>counter2被赋值为0。</li>
</ul>
<blockquote>
<p>注：类被加载进内存后，也可以被卸载。</p>
</blockquote>
<blockquote>
<p><strong>问题1</strong>：类的构造方法是在哪个阶段调用？<br>  答：类的构造方法是在实例化的时候才会被调用，不要和这三个阶段搞混了。实例化已经不是<code>Class层面</code>上的执行步骤了。</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/20/深入理解JVM[课程]_02_类的连接/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/20/深入理解JVM[课程]_02_类的连接/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">02 | 类的连接</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-20 14:19:55" itemprop="dateCreated datePublished" datetime="2019-10-20T14:19:55+08:00">2019-10-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/深入理解JVM-课程/" itemprop="url" rel="index"><span itemprop="name">深入理解JVM[课程]</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎连接的步骤"><a href="#✎连接的步骤" class="headerlink" title="✎连接的步骤"></a><center><font color="#36648B">✎</font><br><font color="#36648B">连接的步骤</font></center></h4><ul>
<li>验证：确保被加载的类的正确性。</li>
<li>准备：为类的<strong>静态变量</strong>分配内存，并将其初始化为<strong>默认值</strong>。</li>
<li>解析：把类中的符号引用转换为直接引用。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/20/深入理解JVM[课程]_01_类的加载/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/20/深入理解JVM[课程]_01_类的加载/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">01 | 类的加载</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-20 13:19:55" itemprop="dateCreated datePublished" datetime="2019-10-20T13:19:55+08:00">2019-10-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/深入理解JVM-课程/" itemprop="url" rel="index"><span itemprop="name">深入理解JVM[课程]</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Java代码中，类型的加载、连接与初始化过程都是在<strong>程序运行期间</strong>完成的</p>
<h4 id="✎相关定义"><a href="#✎相关定义" class="headerlink" title="✎相关定义"></a><center><font color="#36648B">✎</font><br><font color="#36648B">相关定义</font></center></h4><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个<strong>java.lang.Class</strong>对象用来封装类在方法区内的数据结构。</p>
<blockquote>
<p>规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中。</p>
</blockquote>
<p>JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p>
<blockquote>
<p>但是实际情况下，在编译完之后，删除某个类的.class文件，如果需要加载它，会直接报错，而不是等到初始化才报错。</p>
</blockquote>
<p>类加载器并不需要等到某个类被“首次主动使用”时再加载它。</p>
<blockquote>
<p>这里有例子可以证明吗？</p>
</blockquote>
<p>若有一个类加载器能够成功加载Test类，那么这个类加载器被称为<strong>定义类加载器</strong>，所有能成功返回Class对象引用的类加载器（包括定义类加载器）都被称为<strong>初始类加载器</strong>。</p>
<h4 id="✎✎类加载器的类型"><a href="#✎✎类加载器的类型" class="headerlink" title="✎✎类加载器的类型"></a><center><font color="#36648B">✎✎</font><br><font color="#36648B">类加载器的类型</font></center></h4><ul>
<li><p>Java虚拟机自带的加载器</p>
<ul>
<li><strong>根类加载器（Bootstrap）</strong>：该加载器没有父加载器，它负责加载虚拟机的核心类库，如java.lang.*等。根类加载器从系统属性<code>sun.boot.class.path</code>所指定的目录中加载类库。根类加载器的实现依赖于底层操作系统（由C++编写），属于虚拟机的实现的一部分，它并<strong>没有继承</strong><code>java.lang.ClassLoader</code>类</li>
<li><p><strong>扩展类加载器（Extension）</strong>:它的父加载器为<strong>根类加载器</strong>。它从<code>java.ext.dirs</code>系统属性所指定的目录中加载类库，或者从JDK的安装目录的<code>jre\lib\ext</code>子目录（扩展目录）下加载类库，如果把用户创建的JAR文件放在这个目录下，也会自动由扩展类加载器加载。扩展类加载器是纯Java类，<strong>是java.lang.ClassLoader类的子类</strong>。</p>
<blockquote>
<p>扩展类加载器只会去加载.jar结尾的文件，而不会去加载.class结尾的文件。</p>
</blockquote>
</li>
<li><p><strong>系统/应用类加载器（System）</strong>（AppClassLoader）:也称为应用类加载器，它的父加载器为<strong>扩展类加载器</strong>。它从环境变量<code>classpath</code>或者系统属性<code>java.class.path</code>所指定的目录中加载类，它是<strong>用户自定义的类加载器的默认父加载器</strong>。系统类加载器是纯Java类，<strong>是java.lang.ClassLoader类的子类</strong>。</p>
</li>
</ul>
</li>
<li><p>用户自定义的类加载器</p>
<ul>
<li><strong>用户自己定制的java.lang.ClassLoader的子类。</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>根类加载器 &gt; 扩展类加载器 &gt; 系统/应用类加载器 &gt; 自定义的类加载器</strong>(箭头左边为箭头右边的父加载器，但是它们之间的关系并不是继承)<br>  拓展类加载器与应用加载器是由根类加载器去加载的。</p>
</blockquote>
<h4 id="✎✎✎加载信息的打印"><a href="#✎✎✎加载信息的打印" class="headerlink" title="✎✎✎加载信息的打印"></a><center><font color="#36648B">✎✎✎</font><br><font color="#36648B">加载信息的打印</font></center></h4><p>可用<code>-XX:+TraceClassLoading</code>这个vm参数打印vm加载类的信息。</p>
<h4 id="✎✎✎✎类加载的机制"><a href="#✎✎✎✎类加载的机制" class="headerlink" title="✎✎✎✎类加载的机制"></a><center><font color="#36648B">✎✎✎✎</font><br><font color="#36648B">类加载的机制</font></center></h4><p>类加载器用来把类加载到Java虚拟机中。从JDK1.2版本开始，类的加载过程采用<strong>双亲委托机制</strong>，这种机制能更好地保证Java平台的安全。在此委托机制中，<strong>除了Java虚拟机自带的根类加载器</strong>以外，其余的类加载器都有且只有一个父加载器。当Java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则由父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。</p>
<h4 id="✎✎✎✎✎获取类加载器的途径"><a href="#✎✎✎✎✎获取类加载器的途径" class="headerlink" title="✎✎✎✎✎获取类加载器的途径"></a><center><font color="#36648B">✎✎✎✎✎</font><br><font color="#36648B">获取类加载器的途径</font></center></h4><ul>
<li><strong>获得当前类的ClassLoader</strong>：<code>clazz.getClassLoader()</code>。</li>
<li><strong>获得当前线程上下文的ClassLoader</strong>：<code>Thread.currentThread().getContextClassLoader()</code>。</li>
<li><strong>获得系统的ClassLoader</strong>：<code>ClassLoader.getSystemClassLoader()</code>。</li>
<li><strong>获得调用者的ClassLoader</strong>：<code>DriverManager.getCallerClassLoader()</code>。</li>
</ul>
<h4 id="✎✎✎✎✎✎数组的类加载器"><a href="#✎✎✎✎✎✎数组的类加载器" class="headerlink" title="✎✎✎✎✎✎数组的类加载器"></a><center><font color="#36648B">✎✎✎✎✎✎</font><br><font color="#36648B">数组的类加载器</font></center></h4><p>数组的Class对象不是由类加载器加载的，而是由虚拟机<strong>动态生成</strong>的。<br>如果数组元素是原生类型，那么调用数组的<code>getClassLoader()</code>方法将会返回<strong>null</strong>，否则返回的是<strong>加载元素的类加载器</strong>。</p>
<h4 id="✎✎✎✎✎✎✎代码示例"><a href="#✎✎✎✎✎✎✎代码示例" class="headerlink" title="✎✎✎✎✎✎✎代码示例"></a><center><font color="#36648B">✎✎✎✎✎✎✎</font><br><font color="#36648B">代码示例</font></center></h4><p><strong>1、获取当前类的ClassLoader</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       Class&lt;?&gt; clazz = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">       <span class="comment">//获得String类的加载器</span></span><br><span class="line">       ClassLoader classLoader = clazz.getClassLoader();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>加载java.lang.String的类加载器是根类加载器，所以HotSpot虚拟机输出为null。（但是有些虚拟机不是输出为Null，并没有严格的规定）<br>Class.forName的类加载器<strong>默认是调用者的类加载器</strong>。且所加载的类<strong>默认会被初始化</strong>。</p>
<blockquote>
<p><code>Reflection.getcallerClass()</code>可以知道调用者是哪个类。</p>
</blockquote>
<p><strong>2、获取父加载器</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       <span class="comment">//获得系统类加载器（AppClassLoader）</span></span><br><span class="line">       ClassLoader classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">       <span class="comment">//获得系统类加载器的父加载器，也就是拓展类加载器（ExtClassLoader）</span></span><br><span class="line">       classLoader = classLoader.getParent();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3、自定义ClassLoaderDemo1</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//将AppClassLoader作为父加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent, String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);<span class="comment">//将parent作为父加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//byte [] bytes = ...  通过className读取到字节数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(className , bytes , <span class="number">0</span> ,bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"MyClassLoader"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz =classLoader.loadClass(<span class="string">"LoaderTest"</span>);</span><br><span class="line">        Object object =clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoaderTest</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>loadClass的流程</strong>：</p>
<ul>
<li>若已经加载过此class，则直接返回内存里的Class对象。</li>
<li>否则用父加载器去加载此class。</li>
<li>若还是加载不成功，则调用findClass方法去加载class。</li>
</ul>
<blockquote>
<p><strong>问题1</strong>：jvm在启动时，类加载器A根据.class文件创建相应的Class对象，如果后续此类加载器通过LoadClass手动生成Class对象，这两个Class对象有无联系？<br>  答：LoadClass在加载类的时候，会判断此类是不是已经在命名空间内，如果在，则直接返回Class对象。所以这两个Class对象其实是指向同一个地址的。<br>  <strong>问题2</strong>：假设有对象TT，首先<code>new TT()</code>（也就是首次主动调用），后续通过LoadClass手动生成TT的Class对象，再通过<code>newInstance()</code>方法生成一个TT对象，那么后者还算是首次主动调用吗？<br>  答：如果这两个Class对象是同一个，那么就不算是“首次主动使用”。<br>  <strong>问题3</strong>：上述代码要怎么体现双亲委托机制？如果用MyClassLoader去加载类，因为它的Parent ClassLoader是AppClassLoader（默认情况下），从而会一直往上委托，那么实际上加载类的应该是BootStrap ClassLoader？<br>  答：每一个类加载器都有自己指定加载类的路径。每一个类加载器都执行这样的逻辑：如果Parent ClassLoader加载不到才由自己本身去加载.class。<br>  <strong>问题4</strong>：在什么情况下ClassLoader才会判断自己无法加载类？<br>  答：在自己的findClass方法逻辑中定义的。<br>  <strong>问题5</strong>：发现一个很严重的问题：上述的Demo中findClass方法没有被调用。<br>  答：因为LoadClass这个方法会先调用父加载器（本例中为AppClassLoader）去加载class。而不会往下走（执行findClass方法）。把上述例子中的class文件放到classpath外,就会调用findClass方法了。<br>  <strong>问题6</strong>：<code>Class&lt;?&gt; clazz = TT.class</code>这段代码会导致类的加载吗？如果会被加载，那么是被哪个加载器加载？<br>  答：会导致类的加载，类加载器将是当前线程上下文类加载器。<br>  <strong>问题7</strong>：如果新建两个MyClassLoader实例去加载classpath外的.class文件，会调用findClass两次（说明“类只会加载一次”的说法不成立？）。<br>  答：由于实例不同，此时命令空间已经不同了，当然会去加载两次。<br>  <strong>问题8</strong>：如果系统加载器与自定义加载器均加载了同样的类（内存中存在两个Class对象），那么<code>Class&lt;?&gt; clazz = TT.class</code>这样子调用的流程又会是怎么样？<br>  答：如果是加载了此全类名相同的类，那么说明自定义加载器与系统加载器没有任何关系。那么这一句代码使用的类加载器将会是线程上下文类加载器。<br>  <strong>问题9</strong>：自定义加载器加载的类可以引用系统加载器加载的类吗？<br>  答：如果自定义加载器与系统加载器无任何关系，那么两者的类是完全隔离的。</p>
</blockquote>
<blockquote>
<p>若有两个jar包，两个包都存在全类名相同的类，那么会加载路径在前的jar包。</p>
</blockquote>
<h4 id="✎✎✎✎✎✎✎✎命名空间"><a href="#✎✎✎✎✎✎✎✎命名空间" class="headerlink" title="✎✎✎✎✎✎✎✎命名空间"></a><center><font color="#36648B">✎✎✎✎✎✎✎✎</font><br><font color="#36648B">命名空间</font></center></h4><p><strong>1、定义</strong><br>每个类加载器都有自己的命名空间，命名空间由<strong>该加载器及所有父加载器所加载的类</strong>组成。<br>在同一个命名空间中，只会存在一个类。</p>
<blockquote>
<p>本质上就是同一个加载器（同一个实例）不会加载一个类两次。</p>
</blockquote>
<h4 id="✎✎✎✎✎✎✎✎✎类之间的引用"><a href="#✎✎✎✎✎✎✎✎✎类之间的引用" class="headerlink" title="✎✎✎✎✎✎✎✎✎类之间的引用"></a><center><font color="#36648B">✎✎✎✎✎✎✎✎✎</font><br><font color="#36648B">类之间的引用</font></center></h4><p>每个类都会使用自己的类加载器（即加载自身的类加载器）来去加载所依赖的类。</p>
<blockquote>
<p>比如，如果A引用了B类，假设A类的定义类加载器是a，那么此时B类也会被a去加载（前提是a未被加载）。</p>
</blockquote>
<blockquote>
<p><strong>问题1</strong>：如果.class（全类名名相同）由两个不同的类加载器加载，生成两个Class对象，那么由这两个Class对象生成的实例会有什么不同？<br>  1、既然全类名相同的两个.class能被两个不同的类加载器加载，说明这两个加载器不存在任何关系，否则在       委托加载的机制下，其中一个加载器肯定会委托另外一个加载器加载的。<br>  2、由这两个全类名相同的Class对象生成的实例实际上<strong>不是同一个类型</strong>。<br>  3、所以实际上<strong>类型 = classloader实例 + 全类名</strong>。<br>  <strong>问题2</strong>：如果用同一个classloader实例去加载全类名相同的两个类（存放路径不同），那么结果会是如何？<br>  答：以先加载的那个.class为准。后面的会被忽略。因为在后面加载时，加载器会认为此类已经被加载过了（即使存放的路径不同）。</p>
</blockquote>
<center> <h4><font color="#36648B">✎✎✎✎✎✎✎✎✎✎<br>双亲委托机制的好处</font></h4></center>

<ul>
<li>因为所有的类加载的上层加载器中都<strong>必然会有bootstrap classloader</strong>。所以能确保java核心类库（<code>sun.boot.class.path</code>下的类）是由bootstrap classloader 所加载的，确保了核心库的安全。</li>
<li>除了<code>sun.boot.class.path</code>下的类，我们可以通过自定义的加载器创建其他类的独立命名空间。</li>
</ul>
<center> <h4><font color="#36648B">✎✎✎✎✎✎✎✎✎✎✎<br>Launcher</font></h4></center>

<p>Launcher是由<strong>根类加载器</strong>去加载的。</p>
<p><strong>1、自定义系统类加载器</strong><br>根据<code>java.lang.ClassLoader#getSystemClassLoader</code>的描述可知，我们执行以下步骤指定自定义的类加载器为系统类加载器。</p>
<ul>
<li><p>自定义类加载器必须要有一个构造方法，它的参数是ClassLoader。（用来指定自定义类加载器的parent classloader）。</p>
<blockquote>
<p>自定义类加载器由原来默认的系统类加载器加载。且它的parent classloader是默认的系统类加载器。</p>
</blockquote>
</li>
<li>通过<code>java.system.class.loader</code>  属性指定自己实现的加载器为系统类加载器。</li>
</ul>
<p><strong>2、Launcher的构造</strong><br>在Launcher的构造方法中，构造了<strong>ExtClassLoader</strong>与<strong>AppClassLoader</strong>。</p>
<center> <h4><font color="#36648B">✎✎✎✎✎✎✎✎✎✎✎✎<br>线程上下文类加载器</font></h4></center>

<p>Thread类的类加载器是<strong>BootStrap ClassLoader</strong>。</p>
<p>线程上下文类加载器是从JDK 1.2开始引入的，Thread类中的<code>getcontextclassLoader()</code>与<code>setContextClassLoader(ClassLoader cl)</code>分别用来获取和设置上下文类加载器。<br>如果没有显示对上下文类加载器进行设置的话，线程将<strong>继承其父线程的上下文类加载器</strong>。Java应用运行时的初始线程的上下文类加载器是<strong>系统类加载器</strong>。</p>
<p>在双亲委托机制下，父加载器是不能使用子加载器所加载的类的。但是如果使用父加载器的线程中设置线程上下文加载器为子加载器，就可以解决这个问题了。</p>
<blockquote>
<p>这在SPI（Service Provider Interface）中很常见，比如说JDBC等。对于SPI来说，有些接口是Java核心库所提供的，而Java核心库是由启动类加载器来加载的，而这些接口的实现却来自于不同的jar包（厂商提供），一般情况下Java的启动类加载器是会加载其他来源的jar包，这样传统的双亲委托模型就无法满足SPI的要求。而通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于接口实现类的加载。</p>
</blockquote>
<blockquote>
<p>这种场景如果用spring去实现是不是也能很好的解决呢？只关注实例bean，而不关注类。</p>
</blockquote>
<p>线程上下文器的使用的代码示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Claastoader originClassloader = Thread.currentehread().getcontextclaastoader();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//设置为目标类加载器</span></span><br><span class="line">            Thread.currentThread().setcontextclassloader(targetClassLoader);</span><br><span class="line">            <span class="comment">//dosomething  做一些类加载的操作</span></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            Thread.currentThread().setcontextclassloader(originClassloader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<center> <h4><font color="#36648B">✎✎✎✎✎✎✎✎✎✎✎✎✎<br>jar hell问题的定位</font></h4></center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  IOException </span>&#123;</span><br><span class="line">        ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        String resourceName = <span class="string">"Test.class"</span>;</span><br><span class="line">        Enumeration&lt;URL&gt; urls = cl.getResources(resourceName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements())&#123;</span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            System.out.println(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述demo可以打印出<code>Test.class</code>存在哪几个jar包中。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/17/网课_JVM_04_算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/17/网课_JVM_04_算法/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">04 | 算法</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-17 00:33:49" itemprop="dateCreated datePublished" datetime="2019-10-17T00:33:49+08:00">2019-10-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/网课-JVM/" itemprop="url" rel="index"><span itemprop="name">网课_JVM</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎复制算法"><a href="#✎复制算法" class="headerlink" title="✎复制算法"></a><center><font color="#36648B">✎</font><br><font color="#36648B">复制算法</font></center></h4><p><strong>1、使用场景</strong><br>年轻代中使用的是Minor GC，这种GC算法采用的是<strong>复制算法（Copying）</strong>。</p>
<p><strong>2、原理</strong><br>对象在Eden（包括一个Survivor区域，这里假设是from区域）出生，在经过一次MinorGC后，如果对象还存活并且能够被另外一块Survivor区域所容纳（上面已经假设为from区域，这里应为to区域，即to区域有足够的内存空间来存储Eden和from区域中存活的对象），则使用复制算法将这些仍然还存活的对象复制到另外一块Survivor区域（即to区域）中，然后清理所使用过的Eden以及Survivor区域（即from区域），并且将这些对象的年龄设置为1，此时from区与to区角色交换。以后对象在Survivor区每熬过一次MinorGC，就将对象的年龄+1，当对象的年龄达到某个值时（默认是15岁，通过<code>-XX:MaxTenuringThreshold</code>来设定参数），这些对象就会成为老年代。<br>当to区被填满时，则所有对象都会移动到老年区。</p>
<blockquote>
<p>一些大对象会直接被分配在永久区。</p>
</blockquote>
<p><strong>3、优点</strong></p>
<ul>
<li>不会产生内存碎片</li>
</ul>
<p><strong>4、缺点</strong></p>
<ul>
<li>浪费“to区域”的空间。</li>
<li>当对象存活率高时，复制的时间会比较长。</li>
</ul>
<h4 id="✎✎标记清除"><a href="#✎✎标记清除" class="headerlink" title="✎✎标记清除"></a><center><font color="#36648B">✎✎</font><br><font color="#36648B">标记清除</font></center></h4><p><strong>1、使用场景</strong><br>Full GC算法是由<strong>标记清除算法（Mark-Sweep）</strong>实现或是<strong>标记清除/整理算法</strong>混合实现。</p>
<p><strong>2、原理</strong></p>
<ul>
<li>标记：从根集合开始扫描，对存活的对象进行标记。（第一次扫描）</li>
<li>清除：扫描整个内存空间，回收未被标记的对象。（第二次扫描）<blockquote>
<p>为什么要两次扫描？不能第一遍扫描直接清除吗？</p>
</blockquote>
</li>
</ul>
<p><strong>3、优点</strong><br>不需要额外空间。</p>
<p><strong>4、缺点</strong></p>
<ul>
<li>两次扫描，耗时严重。</li>
<li>会产生内存碎片。</li>
</ul>
<h4 id="✎✎✎标记整理"><a href="#✎✎✎标记整理" class="headerlink" title="✎✎✎标记整理"></a><center><font color="#36648B">✎✎✎</font><br><font color="#36648B">标记整理</font></center></h4><p><strong>1、使用场景</strong><br>Full GC算法是由<strong>标记清除算法（Mark-Sweep）</strong>实现或是<strong>标记清除/整理算法</strong>混合实现。</p>
<p><strong>2、原理</strong><br>基于标记清除算法下，再将内存空间整理一遍，消灭内存碎片。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/15/网课_JVM_03_堆/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/15/网课_JVM_03_堆/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">03 | 堆</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-15 00:53:25" itemprop="dateCreated datePublished" datetime="2019-10-15T00:53:25+08:00">2019-10-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/网课-JVM/" itemprop="url" rel="index"><span itemprop="name">网课_JVM</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎堆的结构"><a href="#✎堆的结构" class="headerlink" title="✎堆的结构"></a><center><font color="#36648B">✎</font><br><font color="#36648B">堆的结构</font></center></h4><p><img src="/2019/10/15/网课_JVM_03_堆/堆结构.png" alt=""><br>当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸区进行Minor GC。然后将伊甸区中的剩余对象移动到幸存0区。若幸存0区也满了，则对0区进行Minor GC，然后移动到1区。如果1区也满了，则对1区进行Minor GC，再将剩余对象移动到养老区。若养老区也满了，那么这个时候将产生Full GC（Major GC）。若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生<strong>OOM</strong>。</p>
<p><strong>1、新生区</strong><br>新生区又分为两部分：</p>
<ul>
<li><strong>伊甸区（Eden space）</strong>。</li>
<li><strong>幸存者区（Survivor pace）</strong>。</li>
</ul>
<p>新生区进行的是<strong>Minor GC</strong>。<br>Eden:Survivor0:Survivor1的比例默认是<code>8:1:1</code>。</p>
<p><strong>2、养老区</strong><br>养老区进行的是<strong>Full GC（Major GC）</strong>。</p>
<blockquote>
<p>Full GC偶尔会对新生代、永久代进行GC。<br><strong>连接池对象</strong>一般都在这个区活跃。</p>
</blockquote>
<p><strong>3、永久区</strong><br>永久区<strong>不会被回收</strong>。用于存放JDK自身所携带的Class，Interface的元数据（例如Object类）。</p>
<p><strong>4、方法区</strong><br>java1.8以前，可以理解为<strong>永久区是方法区的实现</strong>。</p>
<h4 id="✎✎代码体现"><a href="#✎✎代码体现" class="headerlink" title="✎✎代码体现"></a><center><font color="#36648B">✎✎</font><br><font color="#36648B">代码体现</font></center></h4><p><strong>1、查看当前可以使用的最大堆内存</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().maxMemory()/1024/1024)</span><br></pre></td></tr></table></figure></p>
<h4 id="✎✎异常分析"><a href="#✎✎异常分析" class="headerlink" title="✎✎异常分析"></a><center><font color="#36648B">✎✎</font><br><font color="#36648B">异常分析</font></center></h4><p><strong>1、java.lang.OutOfMemoryError:Java heap space</strong></p>
<ul>
<li>Java虚拟机设置的堆内存不够大。<blockquote>
<p>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（一直被引用）。</p>
</blockquote>
</li>
</ul>
<p><strong>2、java.lang.0utOfMemoryError:PermGen space</strong></p>
<ul>
<li>Java虚拟机对永久代Perm内存设置不够。<blockquote>
<p>一般出现这种情况，都是程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用。或者大量动态反射生成的类不断被加载，最终导致Perm区被占满。</p>
</blockquote>
</li>
</ul>
<h4 id="✎✎✎JDK版本"><a href="#✎✎✎JDK版本" class="headerlink" title="✎✎✎JDK版本"></a><center><font color="#36648B">✎✎✎</font><br><font color="#36648B">JDK版本</font></center></h4><ul>
<li>Jdk1.6及之前：有永久代，常量池在方法区。</li>
<li>Jdk1.7：有永久代，常量池在堆。</li>
<li>Jdk1.8及之后：无永久代，常量池1.8在元空间。</li>
</ul>
<h4 id="✎✎✎✎堆的配置与GC"><a href="#✎✎✎✎堆的配置与GC" class="headerlink" title="✎✎✎✎堆的配置与GC"></a><center><font color="#36648B">✎✎✎✎</font><br><font color="#36648B">堆的配置与GC</font></center></h4><p><strong>1、java1.7</strong><br><img src="/2019/10/15/网课_JVM_03_堆/堆的配置与GC1.png" alt=""></p>
<p><strong>2、java1.8</strong><br><img src="/2019/10/15/网课_JVM_03_堆/堆的配置与GC2.png" alt=""></p>
<h4 id="✎✎✎✎✎堆内存调优"><a href="#✎✎✎✎✎堆内存调优" class="headerlink" title="✎✎✎✎✎堆内存调优"></a><center><font color="#36648B">✎✎✎✎✎</font><br><font color="#36648B">堆内存调优</font></center></h4><p><strong>1、配置</strong></p>
<ul>
<li><strong>-Xms</strong>：设置初始分配大小，默认为物理内存的<strong>1/64</strong>。</li>
<li><strong>-Xmx</strong>：最大分配内存，默认为物理内存的<strong>1/4</strong>。</li>
<li><strong>-XX:+PrintGCDetails</strong>：输出详细的GC处理日志。<blockquote>
<p>注意：上述分配的堆空间不包含元数据区/方法区，只有新生区和老年区。</p>
</blockquote>
</li>
</ul>
<p><strong>2、代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回 Java 虚拟机试图使用的最大内存量。</span></span><br><span class="line">    <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();</span><br><span class="line">    <span class="comment">//返回 Java 虚拟机中的内存总量。</span></span><br><span class="line">    <span class="keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();</span><br><span class="line">    System.out.println(<span class="string">"MAX_MEMORY = "</span> + maxMemory + <span class="string">"（字节）、"</span> + (maxMemory / (<span class="keyword">double</span>)<span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">"MB"</span>);</span><br><span class="line">    System.out.println(<span class="string">"TOTAL_MEMORY = "</span> + totalMemory + <span class="string">"（字节）、"</span> + (totalMemory / (<span class="keyword">double</span>)<span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">"MB"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/13/网课_JVM_02_栈/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/13/网课_JVM_02_栈/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">02 | 栈</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-13 19:21:32" itemprop="dateCreated datePublished" datetime="2019-10-13T19:21:32+08:00">2019-10-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/JVM/网课-JVM/" itemprop="url" rel="index"><span itemprop="name">网课_JVM</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1、栈是什么？</strong><br>栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，<strong>线程结束栈内存也就释放</strong>，对于栈来说<strong>不存在垃场回收问题</strong>，只要线程一结束该栈就Over，<strong>生命周期和线程一致</strong>，是线程私有的。<strong>基本类型的变量和对象的引用变量</strong>都是在函数的栈内存中分配。</p>
<p><strong>2、栈帧的存储</strong><br>栈帧中主要保存<strong>3类数据</strong>：</p>
<ul>
<li><strong>本地变量（Local Variables）</strong>：输入参数和输出参数以及方法内的变量。</li>
<li><strong>栈操作（Operand Stack）</strong>：记录出栈、入栈的操作。</li>
<li><strong>栈帧数据（Frame Data）</strong>：包括类文件、方法等等。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/09/Kafka权威指南_04_Kafka消费者--从Kafka读取数据/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/09/Kafka权威指南_04_Kafka消费者--从Kafka读取数据/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">04 | Kafka消费者--向Kafka读取数据</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-09 20:56:59" itemprop="dateCreated datePublished" datetime="2019-10-09T20:56:59+08:00">2019-10-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-03-16 20:32:21" itemprop="dateModified" datetime="2020-03-16T20:32:21+08:00">2020-03-16</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Kafka/Kafka权威指南/" itemprop="url" rel="index"><span itemprop="name">Kafka权威指南</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎消费者组"><a href="#✎消费者组" class="headerlink" title="✎消费者组"></a><center><font color="#36648B">✎</font><br><font color="#36648B">消费者组</font></center></h4><p><strong>1、分配分区</strong><br>每个消费者组有一个自己的<strong>群组协调器（broker）</strong>，当消费者要加入群组时，它会向<strong>协调器</strong>发送一个JoinGroup请求。第一个加入群组的消费者将成为“<strong>群主</strong>”。<br>群主可以从协调器那里获得组员的所有信息，并为组员分配分区（通过实现<code>PartitionAssignor</code>接口的类）。群主将分配情况发送给群组协调器，再由群组协调器发送给所有组员。<br>每当消费者离开（主动断开或心跳失败）时会触发再均衡，此时会再重新分区。</p>
<blockquote>
<p>新组员加进来时，是否也会触发再均衡？</p>
</blockquote>
<p>消费者会在<strong>轮询消息</strong>或<strong>提交偏移量</strong>时，发送心跳消息。<br>如果消费组里的消费者，超过主题的分区数量，那么有一部分消费者就会被闲置，不会接收到任何消息。</p>
<h4 id="✎✎消费者的配置"><a href="#✎✎消费者的配置" class="headerlink" title="✎✎消费者的配置"></a><center><font color="#36648B">✎✎</font><br><font color="#36648B">消费者的配置</font></center></h4><p><strong>1、group.id</strong><br>指定组id。</p>
<p><strong>2、fetch.min.bytes与fetch.max.wait.ms</strong><br>fetch.min.bytes表示消费者从服务器获取记录的最小字节数。<br>fetch.max.wait.ms表示获取数据时的等待时间，默认为500ms。<br>两者哪个先被满足就会接收消息。</p>
<p><strong>3、max.partition.fetch.bytes</strong><br>该属性指定了服务器从每个分区里返回给消费者的最大字节数。它的默认值是1MB。</p>
<p><strong>4、session.timeout.ms与heartbeat.interval.ms</strong><br>session.timeout.ms指定了消费者在被认为死亡之前可以与服务器断开连接的时间，默认是3s。<br>heartbeat.interval.ms指定了poll()方法向协调器发送心跳的频率。一般是session.timeout.ms的三分之一。</p>
<p><strong>5、auto.offset.reset</strong><br>该属性指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下（因消费者长时间失效，包含偏移量的记录已经过时并被删除）该作何处理。</p>
<ul>
<li><code>latest</code>。默认值，从最新的记录开始读。</li>
<li><code>earliest</code>。从起始的记录开始读。</li>
</ul>
<p><strong>6、enable.auto.commit</strong><br>是否自动提交偏移量。默认值为true。可以通过<code>auto.commit.interval.ms</code>（默认为5S）来控制自动提交的频率。 </p>
<p><strong>7、partition.assignment.strategy</strong><br>分区分配的策略：</p>
<ul>
<li><code>Range</code>：把主题的若干个连续的分区分配给消费者。</li>
<li><code>RoundRobin</code>：把主题的所有分区逐个分配给消费者。</li>
</ul>
<p><strong>8、client.id</strong><br>客户端Id。</p>
<p><strong>9.max.poll.records</strong><br>该属性用于控制单次调用call()方法能够返回的记录数量。</p>
<p><strong>10.receive.buffer.bytes 和send.buffer.bytes</strong><br>TCP的缓冲区配置。默认为-1（使用操作系统默认值）。</p>
<h4 id="✎✎✎提交"><a href="#✎✎✎提交" class="headerlink" title="✎✎✎提交"></a><center><font color="#36648B">✎✎✎</font><br><font color="#36648B">提交</font></center></h4><p><strong>1、手动提交偏移量</strong><br><code>enable.auto.commit</code>设置为false。并手动调用<code>commitSync()</code>或<code>commitASync()</code>。</p>
<p><strong>2、同步提交与异步提交</strong></p>
<ul>
<li><code>commitSync()</code>：同步提交。如果出错会重试。</li>
<li><code>commitASync()</code>：异步提交。如果出错不会重试，因为如果重试的话有可能会让偏移量小的提交覆盖偏移量大的提交。<blockquote>
<p>解决方法：因为异步提交支持回调，所以可以在本地记录上一次已成功提交的偏移量，在回调方法中，若提交失败则根据当前提交偏移量与本地保存的偏移量决定是否要重试。</p>
</blockquote>
</li>
</ul>
<p>默认情况下，手动提交默认都是提交最后一个偏移量，也可以指定提交特定的偏移量。</p>
<p><strong>3、同步提交与异步提交结合</strong><br>伪代码实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    poll();</span><br><span class="line">    commitASync();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    commitSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="✎✎✎✎再均衡监听器"><a href="#✎✎✎✎再均衡监听器" class="headerlink" title="✎✎✎✎再均衡监听器"></a><center><font color="#36648B">✎✎✎✎</font><br><font color="#36648B">再均衡监听器</font></center></h4><p><strong>1、步骤</strong></p>
<ul>
<li>实现<code>ConsumerRebalanceListener</code>这个类。</li>
<li>在subscribe时，传入ConsumerRebalanceListener实现类。</li>
</ul>
<p><strong>2、作用</strong><br>当发生<code>分区再均衡/分区被分配</code>时，可以通知到消费者，这时我们可以做一些相应的操作（如强制提交偏移量等）。<br>还可以结合<code>seek()</code>方法，在本地维护偏移量（将处理消息与保存偏移量放在同一个事务中）。可以实现消息的“零重复/零丢失”。</p>
<h4 id="✎✎✎✎✎安全的退出"><a href="#✎✎✎✎✎安全的退出" class="headerlink" title="✎✎✎✎✎安全的退出"></a><center><font color="#36648B">✎✎✎✎✎</font><br><font color="#36648B">安全的退出</font></center></h4><p>可以通过<code>consumer.wakeup()</code>方法退出<code>poll()</code>，并且<code>poll()</code>能抛出<code>WakeupException</code>，在退出时最好要调用<code>consumer.close()</code>,因为它会主动地像群组协调器发送自己要离开的消息，而不用等到超时触发再均衡。并且还能主动提交任何还未提交的东西。</p>
<h4 id="✎✎✎✎✎✎读取特定的分区"><a href="#✎✎✎✎✎✎读取特定的分区" class="headerlink" title="✎✎✎✎✎✎读取特定的分区"></a><center><font color="#36648B">✎✎✎✎✎✎</font><br><font color="#36648B">读取特定的分区</font></center></h4><p>可以通过<code>comsumer.assign()</code>方法去读取特定的分区，此时就不需要订阅主题，也不需要群组了。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">aFightz</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">98</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">35</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aFightz</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  


  
  

  

  

  

  

  

  

</body>
</html>
