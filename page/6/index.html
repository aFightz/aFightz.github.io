<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="aFightz">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="aFightz">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="aFightz">






  <link rel="canonical" href="http://yoursite.com/page/6/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>aFightz</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">aFightz</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/15/大数据之Zookeeper_04_Zookeeper实战/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/15/大数据之Zookeeper_04_Zookeeper实战/" class="post-title-link" itemprop="http://yoursite.com/page/6/index.html">04 | Zookeeper实战</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-15 20:02:50" itemprop="dateCreated datePublished" datetime="2019-07-15T20:02:50+08:00">2019-07-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Zookeeper/" itemprop="url" rel="index"><span itemprop="name">Zookeeper</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Zookeeper/大数据之Zookeeper/" itemprop="url" rel="index"><span itemprop="name">大数据之Zookeeper</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎分布式安装部署"><a href="#✎分布式安装部署" class="headerlink" title="✎分布式安装部署"></a><center><font color="#36648B">✎</font><br><font color="#36648B">分布式安装部署</font></center></h4><p><strong>1.集群规划</strong><br>A、B和C三个节点上部署Zookeeper。</p>
<p><strong>2.解压安装。</strong></p>
<ul>
<li>在A的服务器解压安装zk。</li>
<li>同步zk到B、C。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xsync [ZK_PATH]/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>xsync是怎么同步A到B和C上的，在其他地方是否有相关设置？</p>
</blockquote>
<p><strong>3.配置服务器编号。</strong></p>
<ul>
<li>创建目录<code>[dataDir_path]</code>。</li>
<li>在<code>[dataDir_path]</code>目录下创建一个<code>myid</code>的文件。</li>
<li>编辑<code>myid文件</code>，在文件中添加与server对应的唯一编号<code>[SERVER_ID]</code>。</li>
<li>拷贝配置好的zookeeper到其他机器上。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xsync myid</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>并分别在B、C上修改myid文件中内容为自己的<code>[SERVER_ID]</code>。</p>
<p><strong>4.配置 zoo.cfg文件</strong></p>
<ul>
<li>修改配置文件为zoo.cfg。</li>
<li>修改数据存储路径配置dataDir为<code>[dataDir_path]</code>。</li>
<li><p>增加如下配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.[A_ID]=A:2888:3888</span><br><span class="line">server.[B_ID]=B:2888:3888</span><br><span class="line">server.[C_ID]=C:2888:3888</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步zoo.cfg配置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xsync zoo.cfg</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>这里的A、B、C是怎么映射到IP的？</p>
</blockquote>
<h4 id="✎✎配置参数解读"><a href="#✎✎配置参数解读" class="headerlink" title="✎✎配置参数解读"></a><center><font color="#36648B">✎✎</font><br><font color="#36648B">配置参数解读</font></center></h4><p><code>server.A=B:C:D</code></p>
<ul>
<li>A是一个数字，表示这个是第几号服务器。集群模式下在dataDir目录下配置一个文件myid，这个文件里面有一个数据就是A的值，Zookeeper启动时读取此文件，拿到里面的数据与zoo.cfg里面的配置信息比较从而判断到底是哪个server。</li>
<li>B是这个服务器的ip地址。</li>
<li>C是这个服务器与集群中的Leader服务器交换信息的端口。</li>
<li>D是用来执行<strong>重新选举</strong>时服务器相互通信的端口。</li>
</ul>
<h4 id="✎✎✎集群操作"><a href="#✎✎✎集群操作" class="headerlink" title="✎✎✎集群操作"></a><center><font color="#36648B">✎✎✎</font><br><font color="#36648B">集群操作</font></center></h4><ul>
<li>分别启动Zookeeper。</li>
<li>分别查看状态。<br>可从结果中知道这个节点是follower还是leader。</li>
</ul>
<h4 id="✎✎✎✎客户端命令行操作"><a href="#✎✎✎✎客户端命令行操作" class="headerlink" title="✎✎✎✎客户端命令行操作"></a><center><font color="#36648B">✎✎✎✎</font><br><font color="#36648B">客户端命令行操作</font></center></h4><p><strong>1、显示所有操作命令</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help</span><br></pre></td></tr></table></figure></p>
<p><strong>2、查看znode中所包含的内容</strong></p>
<ul>
<li><p>查看当前znode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看sanguo znode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /sanguo</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>3、查看当前节点详细数据</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls2 /</span><br></pre></td></tr></table></figure></p>
<p><strong>4、创建普通节点</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /sanguo &quot;jinlian&quot;</span><br></pre></td></tr></table></figure></p>
<p>也可创建多级目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /sanguo/shuguo &quot;liubei&quot;</span><br></pre></td></tr></table></figure></p>
<p><strong>5、获得节点的值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /sanguo/shuguo</span><br></pre></td></tr></table></figure></p>
<p><strong>6、创建短暂节点</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -e /sanguo/wuguo &quot;zouyu&quot;</span><br></pre></td></tr></table></figure></p>
<p><strong>7、创建带序号的节点</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -s /sanguo/weiguo &quot;caocao&quot;</span><br></pre></td></tr></table></figure></p>
<p><strong>8、修改节点数据值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set /sanguo/shuguo &quot;diaocan&quot;</span><br></pre></td></tr></table></figure></p>
<p><strong>9、节点的值变化监听</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /sanguo watch(只监听一次)</span><br></pre></td></tr></table></figure></p>
<p><strong>10、节点的子节点变化监听（路径变化）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /sanguo watch(只监听一次)</span><br></pre></td></tr></table></figure></p>
<p><strong>11、删除节点</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete /sanguo/banzhang</span><br></pre></td></tr></table></figure></p>
<p><strong>12、递归删除节点</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmr /sanguo</span><br></pre></td></tr></table></figure></p>
<p><strong>13、查看节点状态</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat /sanguo</span><br></pre></td></tr></table></figure></p>
<h4 id="✎✎✎✎API"><a href="#✎✎✎✎API" class="headerlink" title="✎✎✎✎API"></a><center><font color="#36648B">✎✎✎✎</font><br><font color="#36648B">API</font></center></h4><p><strong>1、创建zk客户端</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestZookeeper</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String connectString=<span class="string">"hadoop102:2181,hadoop103:2181,hadoop104:2181"</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout=<span class="number">2000</span>; </span><br><span class="line">    <span class="keyword">private</span> Zookeeper zkClient;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        zkClient=<span class="keyword">new</span> Zookeeper(connectstring,sessionTimeout,<span class="keyword">new</span> Watcher()&#123;</span><br><span class="line">            <span class="meta">@Override</span> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span></span>&#123;</span><br><span class="line">                <span class="comment">//do something</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当有数据变化时，process会被调用。</p>
<p><strong>2、创建一个节点</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createNode</span><span class="params">()</span><span class="keyword">throws</span> KeeperException，InterruptedException</span>&#123;</span><br><span class="line">    String path =zkClient.create（</span><br><span class="line">        <span class="string">"/atguiku"</span>,</span><br><span class="line">        <span class="string">"dahaigezuishuai"</span>.getBytes(),</span><br><span class="line">        Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">        CreateMode.PERSISTENT</span><br><span class="line">    );</span><br><span class="line">    System.out.print1n(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3、获取子节点</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; children = zkClient. getchildren(<span class="string">"/"</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>true表示注册监听。</p>
<p><strong>4、判断节点是否存在</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stat stat=zkclient. exists(<span class="string">"/atguigu"</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>5、监听服务器节点动态上下线</strong><br>流程如下：</p>
<ul>
<li>服务端启动时去注册信息（创建都是临时节点）。</li>
<li>客户端启动就去getChildren，获取到当前在线服务器列表，并且注册监听。</li>
<li>服务器节点下线。</li>
<li>服务器节点上下线事件通知。</li>
<li>process()重新再去获取服务器列表，并注册监听。</li>
</ul>
<p>重点在于服务器向zk注册信息时，创建的节点是<strong>临时的且带编号</strong>的。</p>
<blockquote>
<p>问题：如果多台机创建的path相同（节点相同），那么如果节点是带编号的，就不会重合，但如果不带编号的，又会是什么状况呢？</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/15/大数据之Zookeeper_03_Zookeeper内部原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/15/大数据之Zookeeper_03_Zookeeper内部原理/" class="post-title-link" itemprop="http://yoursite.com/page/6/index.html">03 | Zookeeper内部原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-15 18:43:28" itemprop="dateCreated datePublished" datetime="2019-07-15T18:43:28+08:00">2019-07-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Zookeeper/" itemprop="url" rel="index"><span itemprop="name">Zookeeper</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Zookeeper/大数据之Zookeeper/" itemprop="url" rel="index"><span itemprop="name">大数据之Zookeeper</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎选举机制"><a href="#✎选举机制" class="headerlink" title="✎选举机制"></a><center><font color="#36648B">✎</font><br><font color="#36648B">选举机制</font></center></h4><ul>
<li>半数机制：集群中<strong>半数以上</strong>机器存活，集群可用。所以Zookeeper适合安装<strong>奇数</strong>台服务器。</li>
<li>Zookeeper虽然在配置文件中并没有指定Master和Slave。但是，Zookeeper工作时，如果有一个节点为Leader，其他则为Follower，Leader是通过内部的选举机制临时产生的。</li>
<li>选举（启动时）的过程：<br>一个节点进来时，先投自己，如果没有选出leader，则把票给id最大的server。</li>
</ul>
<h4 id="✎✎节点类型"><a href="#✎✎节点类型" class="headerlink" title="✎✎节点类型"></a><center><font color="#36648B">✎✎</font><br><font color="#36648B">节点类型</font></center></h4><p><strong>1、类型</strong></p>
<ul>
<li><strong>持久（Persistent）</strong>：客户端和服务器端断开连接后，创建的节点不删除。<br>持久分为两种类型：<ul>
<li><strong>持久化目录节点</strong>：客户端与Zookeeper断开连接后，该节点依旧存在。</li>
<li><strong>持久化顺序编号目录节点</strong>：客户端与Zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>短暂（Ephemeral）</strong>：客户端和服务器端断开连接后，创建的节点自己删除。<br>短暂节点可以用作探知client是否在线。（因为如果客户端没连的话，这个节点就被删除了）<br>短暂节点分为两种类型：<ul>
<li><strong>临时目录节点</strong>：客户端与Zookeeper断开连接后，该节点被删除。</li>
<li><strong>临时顺序编号目录节点</strong>：客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号。</li>
</ul>
</li>
</ul>
<p><strong>2、顺序标识</strong><br>创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增的计数器，由<strong>父节点</strong>维护。<br>在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序。</p>
<blockquote>
<p>这个顺序标识可以知道全局中哪个节点先上线。</p>
</blockquote>
<h4 id="✎✎✎Stat结构体"><a href="#✎✎✎Stat结构体" class="headerlink" title="✎✎✎Stat结构体"></a><center><font color="#36648B">✎✎✎</font><br><font color="#36648B">Stat结构体</font></center></h4><ul>
<li>czxid：创建节点的事务zid<ul>
<li>每次修改ZooKeeper状态都会收到一个zxid形式的时间戳，也就是<strong>ZooKeeper事务ID</strong>。</li>
<li>事务ID是ZooKeeper中所有修改总的次序。每个修改都有<strong>唯一</strong>的zxid，如果zxid1小于zxid2，那么zxid1在zxid2之前发生。</li>
</ul>
</li>
<li>ctime-znode：被创建的毫秒数（从1970年开始）。</li>
<li>mzxid-znode：最后更新的事务zxid。</li>
<li>mtime-znode：最后修改的毫秒数（从1970年开始）。</li>
<li>pZxid-znode：最后更新的子节点zxid。</li>
<li>cversion-znode：子节点变化号，zmode子节点修改次数。</li>
<li>dataversion-znode：数据变化号。</li>
<li>aclVersion-znode：访问控制列表的变化号。</li>
<li>ephemeralOwner：如果是临时节点，这个是znode拥有者的session id。如果不是临时节点则是0。</li>
<li>dataLength：znode的数据长度。</li>
<li>numChildren：znode子节点数量。</li>
</ul>
<h4 id="✎✎✎✎监听器原理"><a href="#✎✎✎✎监听器原理" class="headerlink" title="✎✎✎✎监听器原理"></a><center><font color="#36648B">✎✎✎✎</font><br><font color="#36648B">监听器原理</font></center></h4><p><strong>1、监听过程</strong></p>
<ul>
<li>首先要有一个main()线程。</li>
<li>在main线程中创建Zookeeper客户端，这时就会创建两个线程，一个负责网络连接通信（connet），一个负责监听（listener）。</li>
<li>通过connect线程将注册的监听事件发送给Zookeeper。</li>
<li>在Zookeeper的注册监听器列表中将注册的监听事件添加到列表中。</li>
<li>Zookeeper监听到有数据或路径变化，就会将这个消息发送给listener线程。</li>
<li>listener线程内部调用了process()方法。(回调方法)</li>
</ul>
<h4 id="✎✎✎✎✎写数据流程"><a href="#✎✎✎✎✎写数据流程" class="headerlink" title="✎✎✎✎✎写数据流程"></a><center><font color="#36648B">✎✎✎✎✎</font><br><font color="#36648B">写数据流程</font></center></h4><ul>
<li>Client向ZooKeeper的Server1上写数据，发送一个写请求。</li>
<li>如果Server1不是Leader，那么Server1会把接受到的请求进一步转发给Leader，因为每个ZooKeeper的Server里面有一个是Leader。这个Leader会将写请求广播给各个Server，比如Server1和Server2，各个Server写成功后就会通知Leader。</li>
<li>当Leader收到大多数(半数以上)Server数据写成功了，那么就说明数据写成功了。<blockquote>
<p>如果这里三个节点的话，只要有两个节点数据写成功了，那么就认为数据写成功了。写成功之后，Leader会告诉Server1数据写成功了。</p>
</blockquote>
</li>
<li>Server1会进一步通知Client数据写成功了，这时就认为整个写操作成功。</li>
</ul>
<p><img src="/2019/07/15/大数据之Zookeeper_03_Zookeeper内部原理/写数据过程.jpg" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/15/大数据之Zookeeper_02_Zookeeper安装/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/15/大数据之Zookeeper_02_Zookeeper安装/" class="post-title-link" itemprop="http://yoursite.com/page/6/index.html">02 | Zookeeper安装</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-15 17:10:02" itemprop="dateCreated datePublished" datetime="2019-07-15T17:10:02+08:00">2019-07-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Zookeeper/" itemprop="url" rel="index"><span itemprop="name">Zookeeper</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Zookeeper/大数据之Zookeeper/" itemprop="url" rel="index"><span itemprop="name">大数据之Zookeeper</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎安装"><a href="#✎安装" class="headerlink" title="✎安装"></a><center><font color="#36648B">✎</font><br><font color="#36648B">安装</font></center></h4><p><strong>1、解压</strong></p>
<ul>
<li>安装jdk。</li>
<li>拷贝Zookeeper安装包到Linux系统下。</li>
<li>解压到指定目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf [zookeeper.tar.gz] -C [PATH]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>2、配置修改</strong></p>
<ul>
<li><p>将<code>[zk解压路径]/conf</code>这个路径下的<code>zoo_sample.cfg</code>修改为<code>zoo.cfg</code>；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开zoo.cfg文件，修改dataDr路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataDir=[自定义的zkData路径]</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据dataDir配置在相应的目录上创建相应文件夹。</p>
</li>
</ul>
<p><strong>3、操作Zookeeper</strong></p>
<ul>
<li><p>启动Zookeeper</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ZK_PATH]/bin/zkServer.sh start</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看进程是否启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ZK_PATH]/jps</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ZK_PATH]/bin/zkServer.sh status</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以知道这个server是leader还是follower。</p>
<ul>
<li><p>启动客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ZK_PATH]/bin/zkCli.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>退出客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止Zookeeper</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ZK_PATH]/bin/zkServer.sh stop</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端查看根节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="✎✎配置参数解读"><a href="#✎✎配置参数解读" class="headerlink" title="✎✎配置参数解读"></a><center><font color="#36648B">✎✎</font><br><font color="#36648B">配置参数解读</font></center></h4><ul>
<li><p><strong>tickTime=2000</strong><br>每隔一个tickTime就会发送一个心跳，时间单位为毫秒。它用于心跳机制，并且设置session的最小超时时间是<code>2*tickTime</code>。</p>
</li>
<li><p><strong>initLimit=10</strong><br>LF初始通信时限。集群中的Follower与Leader之间初始连接时最长等待时间为<code>initLimit*tickTime</code>。</p>
</li>
<li><p><strong>syncLimit=5</strong><br>LF同步通信时限。假如响应超过<code>syncLimit*tickTime</code>，Leader认为Follwer死掉，从服务器列表中删除Follwer。</p>
</li>
<li><p><strong>dataDir</strong><br>数据文件目录+数据持久化路径。主要用于保存Zookeeper中的数据。</p>
</li>
<li><p><strong>clientPort=2181</strong><br>客户端连接端口监听客户端连接的端口。</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/15/大数据之Zookeeper_01_Zookeeper入门/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/15/大数据之Zookeeper_01_Zookeeper入门/" class="post-title-link" itemprop="http://yoursite.com/page/6/index.html">01 | Zookeeper入门</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-15 12:56:07" itemprop="dateCreated datePublished" datetime="2019-07-15T12:56:07+08:00">2019-07-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Zookeeper/" itemprop="url" rel="index"><span itemprop="name">Zookeeper</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Zookeeper/大数据之Zookeeper/" itemprop="url" rel="index"><span itemprop="name">大数据之Zookeeper</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎概述"><a href="#✎概述" class="headerlink" title="✎概述"></a><center><font color="#36648B">✎</font><br><font color="#36648B">概述</font></center></h4><p>Zookeeper是一个开源的分布式的，为分布式应用提供协调服务的Apache项目。</p>
<h4 id="✎✎工作机制"><a href="#✎✎工作机制" class="headerlink" title="✎✎工作机制"></a><center><font color="#36648B">✎✎</font><br><font color="#36648B">工作机制</font></center></h4><p>Zookeeper从设计模式角度来理解：是一个基于<strong>观察者模式</strong>设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就通知已经在Zookeeper上注册的其他观察者。</p>
<blockquote>
<p><strong>联想：</strong><br>Eureka客户端是定时去注册中心获取服务。并把获取到的服务列表缓存起来。<br>而zk在服务器列表有变化时，会发送消息给客户端，客户端就会重新向zk缓存服务列表。<br>也就是说，对服务列表变化非常敏感的场景，zk应该是更好的选择。</p>
</blockquote>
<h4 id="✎✎✎工作机制"><a href="#✎✎✎工作机制" class="headerlink" title="✎✎✎工作机制"></a><center><font color="#36648B">✎✎✎</font><br><font color="#36648B">工作机制</font></center></h4><p><img src="/2019/07/15/大数据之Zookeeper_01_Zookeeper入门/特点.jpg" alt=""></p>
<ul>
<li>一个领导者（Leader），多个跟随者（Follower）组成的集群。</li>
<li>集群中只要有<strong>半数以上</strong>节点存活，zk集群就能正常服务。</li>
<li>全局数据一致：每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。</li>
<li>更新请求顺序进行，来自同一个Client的更新请求按其发送顺序依次执行。</li>
<li>数据更新原子性，一次数据更新要么成功，要么失败。</li>
<li>实时性，在一定时间范围内，Client能读到最新数据。</li>
</ul>
<h4 id="✎✎✎✎数据结构"><a href="#✎✎✎✎数据结构" class="headerlink" title="✎✎✎✎数据结构"></a><center><font color="#36648B">✎✎✎✎</font><br><font color="#36648B">数据结构</font></center></h4><p><img src="/2019/07/15/大数据之Zookeeper_01_Zookeeper入门/节点.jpg" alt=""><br>ZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一棵树，每个节点称做一个ZNode。每一个ZNode默认能够存储<strong>1MB</strong>的数据，每个ZNode都可以通过其路径唯一标识。</p>
<h4 id="✎✎✎✎✎应用场景"><a href="#✎✎✎✎✎应用场景" class="headerlink" title="✎✎✎✎✎应用场景"></a><center><font color="#36648B">✎✎✎✎✎</font><br><font color="#36648B">应用场景</font></center></h4><p>提供的服务包括：<strong>统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡</strong>等。</p>
<p><strong>1、统一命名服务</strong><br>在分布式环境下，经常需要对应用/服务进行统一命名，便于识别。（类似Eureka Server）</p>
<p><strong>2、统一配置管理</strong><br><img src="/2019/07/15/大数据之Zookeeper_01_Zookeeper入门/统一配置.jpg" alt=""></p>
<ul>
<li>将配置信息写入ZooKeeper上的一个Znode。</li>
<li>各个客户端服务器监听这个Znode。</li>
<li>一旦Znode中的数据被修改，zk将通知各个客户端服务器。</li>
</ul>
<p><strong>3、服务器节点动态上下线</strong><br>客户端能<strong>实时洞察</strong>到服务器上下线的变化，过程如下：</p>
<ul>
<li>服务端启动时去注册信息（创建都是临时节点）。</li>
<li>客户端获取到当前在线服务器列表，并且<strong>注册监听</strong>。</li>
<li>服务器节点下线，将通知客户端。</li>
</ul>
<p><strong>4、软负载均衡</strong><br>在Zookeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/09/Java核心技术卷1_05_继承/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/09/Java核心技术卷1_05_继承/" class="post-title-link" itemprop="http://yoursite.com/page/6/index.html">05 | 继承</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-09 16:13:20" itemprop="dateCreated datePublished" datetime="2019-07-09T16:13:20+08:00">2019-07-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Java/Java核心技术卷1/" itemprop="url" rel="index"><span itemprop="name">Java核心技术卷1</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎子类构造器"><a href="#✎子类构造器" class="headerlink" title="✎子类构造器"></a><center><font color="#36648B">✎</font><br><font color="#36648B">子类构造器</font></center></h4><p>如果子类的构造器没有显示地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器。如果超类没有默认的构造器，而且子类又没有显示地调用超类其他的构造器，那么会编译错误。</p>
<blockquote>
<p>所以这就是有些类的构造方法中为什么一定要有super的原因</p>
</blockquote>
<p>一个对象变量可以指示多种实际类型的现象被称为<font color="#CD5555">多态</font>，在运行时能够自动地选择调用哪个方法的现象称为<font color="#CD5555">动态绑定</font>。</p>
<ul>
<li>子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型的转换。</li>
<li>同样的子类对象的引用可以转换成超类对象的引用，而不需要采用强制类型的转换。</li>
</ul>
<blockquote>
<p>总的来说就是：<br>引用一定要“&gt;=”对象。<br>赋值时，左边的引用要“&gt;=”右边的引用，否则需要强转。（有可能强转失败）</p>
</blockquote>
<p>Employee类（父类）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Manager类（子类）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下代码会导致<code>ArrayStoreException</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manager[] managers = <span class="keyword">new</span> Manager[<span class="number">10</span>];</span><br><span class="line">Employee[] staff = managers;</span><br><span class="line">staff[<span class="number">0</span>] = <span class="keyword">new</span> Employee(); <span class="comment">//出错在这一步</span></span><br><span class="line">managers[<span class="number">0</span>].say();</span><br></pre></td></tr></table></figure></p>
<h4 id="✎✎理解方法调用"><a href="#✎✎理解方法调用" class="headerlink" title="✎✎理解方法调用"></a><center><font color="#36648B">✎✎</font><br><font color="#36648B">理解方法调用</font></center></h4><p><strong>1、方法调用过程</strong><br>假设要调用<code>x.f(args)</code>，x声明为类C的一个对象。下面是调用过程：</p>
<ul>
<li>如果是private方法，static方法，final方法或者构造器，那么编译器可以直接知道在哪个类中调用方法（因为这些方法不能重写）。这种调用方式称为<font color="#CD5555">静态绑定</font>。其他的都称为<font color="#CD5555">动态绑定</font>。如果是动态绑定则继续按下个步骤走。</li>
<li>编译器查看对象的声明类型和方法名。编译器将会列举C类中名为f的方法和其超类中访问属性为public(protected与default不行？)且名为f的方法以及子类中名为f的方法。至此，编译器已经获得所有候选方法。</li>
<li><p>编译器查看调用方法时提供的参数类型。在候选方法中找到与之参数类型完全匹配的方法。否则将会报错。至此，编译器已经获得了需要调用的方法名以及参数类型。</p>
</li>
<li><p>当采用动态绑定调用方法时。假设x的实际类型是D，它是C类的子类。如果D类定义了f(args)，就直接调用；否则将在C类查找f(args)。</p>
</li>
</ul>
<p>Demo：调用<code>e.getSalary()</code>的详细过程</p>
<ul>
<li><p>由于<code>getSalary</code>不是<code>private</code>方法、<code>static</code>方法或<code>final</code>方法，所以将采用<font color="#CD5555">动态绑定</font>。虚拟机为<code>Employee</code>和<code>Manager</code>两个类生成方法表（如果Employee有子类，也会为子类生成方法表）。在<code>Employee</code>的方法表中，列出了这个类定义的所有方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Employee：</span><br><span class="line">   getName() -&gt; Employee.getName()</span><br><span class="line">   getSalay() - &gt; Employee.getSalary()</span><br><span class="line">   getHireDay() -&gt; Employee.getHireDay();</span><br><span class="line">   raiseSalary(double) -&gt; Employee. raiseSalary(double)</span><br></pre></td></tr></table></figure>
<p>Manager方法表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Manager：</span><br><span class="line">   getName() -&gt; Employee.getName()</span><br><span class="line">   getSalay() - &gt; Manager .getSalary()</span><br><span class="line">   getHireDay() -&gt; Employee.getHireDay();</span><br><span class="line">   raiseSalary(double) -&gt; Employee. raiseSalary(double)</span><br><span class="line">   setBonus(double) -&gt; Manager.setBonus(double)</span><br></pre></td></tr></table></figure>
<p>三个方法是继承Employee的，一个方式是重新定义的，一个方法是新增加的。</p>
<blockquote>
<p>方法表略去了Object的方法。</p>
</blockquote>
</li>
<li><p>虚拟机搜索定义getSalary签名的类。此时虚拟机已经知道该调用哪个方法。</p>
</li>
<li>虚拟机调用方法。</li>
</ul>
<p><strong>2、覆盖方法时的注意事项</strong></p>
<ul>
<li>子类方法不能低于超类方法的可见性。</li>
<li>允许子类将覆盖方法的返回类型定义为原返回类型的子类型。如下：</li>
</ul>
<h4 id="✎✎✎阻止继承-：-final类与方法"><a href="#✎✎✎阻止继承-：-final类与方法" class="headerlink" title="✎✎✎阻止继承 ： final类与方法"></a><center><font color="#36648B">✎✎✎</font><br><font color="#36648B">阻止继承 ： final类与方法</font></center></h4><p><strong>1、final</strong><br>final修饰的类与方法不能被继承。</p>
<p>将一个类定义为final后，这个类的<strong>全部方法都将变为final，但属性并不会变成final</strong>。</p>
<p>早期的Java中，有些程序员为了避免动态绑定带来的系统开销而使用final关键字。</p>
<p><strong>2、内联</strong><br>如果一个方法<strong>没有被覆盖</strong>、被调用很频繁并且很短，编译器就能够对它进行优化，这个过程被称为内联。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.g 如果getName()方法没有被覆盖，内联调用e.getName()将被替换为访问e.name域。</span><br></pre></td></tr></table></figure>
<p>如果getName()在另外一个类中被覆盖，编译器无法知道被覆盖的代码将做什么操作，也就不能对它进行内联处理了。</p>
<p>当虚拟机加载了另外一个子类，而这个子类中包含了对内联方法的覆盖，那么优化器将取消对覆盖方法的内联。</p>
<p>在继承链上进行向下的转换会报<code>ClassCastException</code>错误，所以在强转前最好先事先用<code>instanceof</code>判断一下。<br>e.g.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(C <span class="keyword">instanceof</span> D)&#123;<span class="comment">//假设C是D的子类</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>如果C为null，也不会产生异常</strong>。</p>
<p><strong>3、equals</strong></p>
<p>重写equals Demo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == otherObj)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(otherObj == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(getClass() != otherObj.getClass())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Employee other = (Employee)otherObj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.flag == other.flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Objects.equals(a,b)</code>：可以避免a为空导致a.equals(b)出错的情况。<br><code>static boolean equals(Object a ,Object b)</code>：如果a和b都为null，返回true；如果只有其中之一为null，则返回false；否则返回a.equals(b)。（这个方法在实际中还是挺好用的）</p>
<p>在子类定义equals方法时，首先调用超类的equals(前提是超类已经重写了equals方法)。如果检测失败，对象就不可能相等。</p>
<p>子类重写equals Demo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mFlag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">super</span>.equals(otherObj))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Manager other = (Manager)otherObj;</span><br><span class="line">        <span class="keyword">return</span> mFlag == other.mFlag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java语言规范要求equals方法具有下面的特性：</p>
<ul>
<li>自反性：对于任何非空引用x，x.equals(x)应该返回true。</li>
<li>对称性。对于任何引用x和y，当且仅当y.equlas(x)返回true，x.equals(y)也应该发挥true。</li>
<li>传递性。对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，x.equals(z)也应该返回true。</li>
<li>一致性。如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样结果。</li>
<li>对于任意非空引用x，x.equals(null)应该返回false。</li>
</ul>
<p>在上述的Employee类中，如果用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(otherObj <span class="keyword">instanceof</span> Employee)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代替<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(getClass() != otherObj.getClass())&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样会违反对称性原则，原因如下：<br>假设e是Employee对象，而m是一个Manager对象，假设两个对象的属性都相同。当调用e.quals(m)时，会返回true。而调用m.equals(e)时，会出现ClassCastException错误，因为在检验过程中Employee无法转换成为Manager。</p>
<p>如果用getClass的方式检测的话，<code>e.quals(m)返回false，m.equals(e)返回false</code>，符合对称性原则，但是又会违反里氏置换原则。所以这是一个矛盾的点。</p>
<blockquote>
<p><strong>里氏置换原则</strong>：所有引用基类的地方必须能够透明的使用其子类对象。也就是说，只要父类出现的地方子类就能够出现，而且替换为子类不会产生任何错误或异常。但是反过来，子类出现的地方，替换为父类就可能出现问题了。</p>
</blockquote>
<p>Java中有一个<code>AbstractSet</code>类的equals方法检测两个集合是否有相同元素。AbstractSet类有两个具体的实现类：TreeSet和HashSet，它们分别使用不同的算法实现查找集合的操作。无论集合采用何种方式实现，都需要拥有对任意两个集合进行比较的功能。集合是一个相当特殊的例子，因为没有一个子类需要重新定义集合是否相等的语义，所以AbstractSet的equals方法应该被声明为final(实际上并没有)。所以有一个隐患就是如果AbstractSet的子类重写了equals方法，则会出现上述的矛盾问题。</p>
<p>所以可以总结出以下两条法则：</p>
<ul>
<li>如果超类有自己的相等概念且本类也拥有自己的的相等概念（即“上头 ”有自己的相等概念），则对称性需求将强制采用<code>getClass</code>进行检测。</li>
<li>如果只由本类决定是否相等。（即“上头 ”没有自己的相等概念 ），那么就可以使用<code>instanceof</code>，并且将equals方法声明为final。这种情况不会违反任何原则。</li>
</ul>
<p>对于数组类型的域，可以使用静态的Arrays.equals方法检测相应的数组元素是否相等。<br><code>static Boolean equals(type[] a ,type[] b)</code><br>如果两个数组成都相同，并且在对应的位置上数据元素也均相同，将返回true。数组的类型可以是Object、int、long、short、char、byte、boolean、float或double。（也可以是他们相应的包装器类）</p>
<h4 id="✎✎✎✎hashCode方法"><a href="#✎✎✎✎hashCode方法" class="headerlink" title="✎✎✎✎hashCode方法"></a><center><font color="#36648B">✎✎✎✎</font><br><font color="#36648B">hashCode方法</font></center></h4><p>String类使用下列算法计算散列码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash; <span class="comment">//hash默认为0</span></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;  <span class="comment">//value就是String值，用char[]类型存储。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>为什么是31？</strong> </p>
<ul>
<li>31*i = (i&lt;&lt;5)-i，jvm可以对这个乘法进行优化，用移位以及减法代替。</li>
<li>31不会太大也不会太小。</li>
</ul>
</blockquote>
<p>可以知道，String的散列值是<strong>根据String值</strong>算出来的。<br>由于hashCode方法定义在<code>Object</code>类中，因此<strong>每个对象都有一个默认的散列码，其值为对象的存储地址</strong>。</p>
<p>用以下例子可以验证上面的结论：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"OK"</span>;</span><br><span class="line">String t = <span class="keyword">new</span> String(<span class="string">"OK"</span>);</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(s);</span><br><span class="line">StringBuffer tb = <span class="keyword">new</span> StringBuffer(t);</span><br><span class="line">System.out.println(s.hashCode() +<span class="string">" "</span>+sb.hashCode());<span class="comment">//2524 1163157884</span></span><br><span class="line">System.out.println(t.hashCode() +<span class="string">" "</span>+tb.hashCode());<span class="comment">//2524 1956725890</span></span><br></pre></td></tr></table></figure></p>
<p>如果要重新定义equals方法，就必须重新定义hashCode方法，以便用户可以将对象插入到<strong>散列表</strong>中。</p>
<p>hashCode方法应该返回一个整型数值（可以为负数）。</p>
<p>以下是Employee方法的hashCode方法Demo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span> * name.hashCode() + <span class="number">11</span> * number.hashCode() + <span class="number">13</span> * <span class="keyword">new</span> Double(salary).hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过上面的Demo有一个缺陷，就是name有可能为空，为此可以用以下方法代替:</p>
<p><code>static int hashCode(Object a)</code>:<br>如果a为null就返回0，否则就返回a.hashCode()，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span> * Objects.hashCode(name ) + <span class="number">11</span> * Objects.hashCode (number )  + <span class="number">13</span> * Double.hashCode (salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有更好的做法，如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name,salary,number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>static int hash(Object... objects)</code>:<br>返回一个散列码，由提供的所有对象的散列码组合而成。</p>
<p>Equals与hashCode的定义必须一致：如果x.equals(y)返回true，那么x的hashIndex就必须等于y的hashIndex(hashcode也可以不一样)。 如果equals方法返回false，hashcode可以相等，但是这样不利于哈希表的性能。<br>哈希表判断对象是否相同的依据是equals与hashIndex都相同。<br>如果存在数组类型的域，那么可以使用静态的<code>Arrays.hashCode</code>方法计算一个散列码，这个散列码由数组元素的散列码组成。</p>
<h4 id="✎✎✎✎✎toString方法"><a href="#✎✎✎✎✎toString方法" class="headerlink" title="✎✎✎✎✎toString方法"></a><center><font color="#36648B">✎✎✎✎✎</font><br><font color="#36648B">toString方法</font></center></h4><p>Object类定义了<code>toString</code>方法，用来打印输出<strong>对象所属的类名和散列码</strong>。</p>
<h4 id="✎✎✎✎✎✎泛型数组列表"><a href="#✎✎✎✎✎✎泛型数组列表" class="headerlink" title="✎✎✎✎✎✎泛型数组列表"></a><center><font color="#36648B">✎✎✎✎✎✎</font><br><font color="#36648B">泛型数组列表</font></center></h4><p>如果已经清楚或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用<code>ensureCapacity</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff.ensureCapacity(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>ArrayList如果没有一次性扩到想要的最大容量的话，它就会在添加元素的过程中，一点一点的进行扩容，而对数组扩容是要进行数组拷贝的，这就会浪费大量的时间。而ensureCapacity可以一次性扩容到指定的数量。如果指定的容量小于原来数组容量的1.5倍+1，那么扩容的容量将会是原来的1.5倍+1，否则数组容量将被扩容到指定的容量。<br>还可以把初始容量传递给ArrayList构造器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>
<p>一旦确认数组列表的大小不再发生变化，就可以调用<code>trimToSize</code>方法。这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收器将回收多余的存储空间。</p>
<p>只有i小于或等于数组列表的大小时，才能够调用list.set(i,x)。以下这段代码是错误的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; employeeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">employeeList.set(<span class="number">0</span>,<span class="string">"1"</span>);</span><br></pre></td></tr></table></figure></p>
<p>会报错：<code>IndexOutOfBoundsException</code></p>
<h4 id="✎✎✎✎✎✎✎对象包装器与自动装箱"><a href="#✎✎✎✎✎✎✎对象包装器与自动装箱" class="headerlink" title="✎✎✎✎✎✎✎对象包装器与自动装箱"></a><center><font color="#36648B">✎✎✎✎✎✎✎</font><br><font color="#36648B">对象包装器与自动装箱</font></center></h4><p>对象包装器类拥有很明显的名字：<strong>Integer、Long、Float、Double、Short、Byte、Character、Void和Boolean</strong>（前6个类派生于公共的超类<strong>Number</strong>）。<br>对象包装类是<strong>不可变</strong>的，即一旦构造了包装器，就不允许更改包装在其中的值。同时，对象包装器类还是<strong>final</strong>，因此<strong>不能定义它们的子类</strong>。</p>
<p>自动装箱Demo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>将自动变换成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.add(Integer.valueof(<span class="number">3</span>))</span><br></pre></td></tr></table></figure></p>
<p>自动拆箱Demo:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = list.get(i);</span><br></pre></td></tr></table></figure></p>
<p>会被翻译器自动翻译成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = list.get(i).intValue();</span><br></pre></td></tr></table></figure></p>
<p>甚至在算数表达式中也能自动地装箱和拆箱：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer n = <span class="number">3</span>;</span><br><span class="line">n++;</span><br></pre></td></tr></table></figure></p>
<p>编译器将自动插入一条对象拆箱的指令，然后进行自增计算，最后再将结果装箱。</p>
<h4 id="✎✎✎✎✎✎✎✎直接赋值与new的区别"><a href="#✎✎✎✎✎✎✎✎直接赋值与new的区别" class="headerlink" title="✎✎✎✎✎✎✎✎直接赋值与new的区别"></a><center><font color="#36648B">✎✎✎✎✎✎✎✎</font><br><font color="#36648B">直接赋值与new的区别</font></center></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"a"</span>;</span><br><span class="line">String s2 = <span class="string">"a"</span>;</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure>
<p>上面的值中<code>s1==s2 , s3!=s4 , s1!=s3</code>。原因是:</p>
<ul>
<li>直接赋值时，编译器会先去常量池（不是堆也不是栈）找是否存在<code>a</code>,没有的话在常量池创建值为<code>a</code>的对象，此时<code>s1</code>再引用这个对象，此时常量池已经存在了值为<code>a</code>的对象，所以s1与s2引用的也是同一个对象。</li>
<li>而用new操作时，会在堆中创建一个新的对象。</li>
</ul>
<blockquote>
<p><strong>注</strong>：==比较的是对象的内存地址,与hashcode没有任何一点关系。</p>
</blockquote>
<p><strong>==陷阱</strong><br>当在以下值的范围内，采用直接赋值方式且value相等的包装箱类，使用“==”的情况:</p>
<ul>
<li><p><strong>Integer</strong>。在<code>-128~127</code>范围内返回true。<br>编译器会把值-128~127的Integer类缓存,以后当要赋值在此范围的Integer时，直接去缓存里面找。</p>
</li>
<li><p><strong>Short</strong>。在<code>-128~127</code>范围内返回true。<br>类似Integer。</p>
</li>
<li><p><strong>Byte</strong>。永远都返回true。<br>类似Integer，并且byte的范围是-128~127，所以肯定会返回true。</p>
</li>
<li><p><strong>Long</strong>。在<code>-128~127</code>范围内返回true。<br>类似Integer。</p>
</li>
<li><p><strong>Character</strong>。在<code>0~127</code>范围内返回true。<br>编译器会把值0~127的Character类缓存,以后当要赋值在此范围的Character时，直接去缓存里面找。</p>
</li>
<li><p><strong>Boolean</strong>。永远返回true。（用字符串形式赋值时，不区分大小写，非”true”的其他值都为”false”）<br>Boolean类里边定义了值为true和false的两个final类。不管Boolean的值是什么都只会引用这两个类。</p>
</li>
<li><p><strong>Float</strong>。永远返回false。<br>返回值是直接根据float值new出来的Float对象</p>
</li>
<li><p><strong>Double</strong>。永远返回false。<br>类似Float。</p>
</li>
</ul>
<p>如果在一个条件表达式中混合使用Integer和Double类型，Integer就会拆箱，提升为double，再装箱为Double。</p>
<p>如果想编写可以改变一个可以修改数值参数（假设为int类型）的方法，不能用Integer，因为Integer类是不可改变的。可以用<code>IntHolder</code>。</p>
<h4 id="✎✎✎✎✎✎✎✎✎参数数量可变的方法"><a href="#✎✎✎✎✎✎✎✎✎参数数量可变的方法" class="headerlink" title="✎✎✎✎✎✎✎✎✎参数数量可变的方法"></a><center><font color="#36648B">✎✎✎✎✎✎✎✎✎</font><br><font color="#36648B">参数数量可变的方法</font></center></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Object...)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Object..</code>参数类型与<code>Object[]</code>完全一样。<br>调用时像以下这样调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test(Object1 , Object2);</span><br></pre></td></tr></table></figure></p>
<h4 id="✎✎✎✎✎✎✎✎✎✎枚举类"><a href="#✎✎✎✎✎✎✎✎✎✎枚举类" class="headerlink" title="✎✎✎✎✎✎✎✎✎✎枚举类"></a><center><font color="#36648B">✎✎✎✎✎✎✎✎✎✎</font><br><font color="#36648B">枚举类</font></center></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> TestEnum &#123;</span><br><span class="line">    ONE,</span><br><span class="line">    TWO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个声明定义的类型是一个类，它刚好有2个<strong>实例</strong>，所以在比较两个枚举类型的值时，永远不需要调用equals，而直接使用“==”就可以了。</p>
<blockquote>
<p><strong>可以与单例模式关联起来</strong>。</p>
</blockquote>
<p>可以在枚举类型中添加一些构造器、方法和属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> TestEnum &#123;</span><br><span class="line">    ONE(<span class="number">1</span>),</span><br><span class="line">    TWO(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> Integer value;</span><br><span class="line">    TestEnum(Integer value)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>static Enum valueOf(Class enumClass , String name)</code><br>返回指定名字、给定类的枚举常量。</p>
<p><code>String toString()</code><br>返回枚举常量名。</p>
<p><code>int ordinal()</code><br>返回枚举常量在enum声明中的位置，位置从0开始计数。</p>
<p><code>int compareTo(E other)</code><br>如果枚举常量出现在other之前，则返回一个负值；如果this==other，则返回0；否则返回正值。枚举常量的出现次序在enum声明中给出。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/09/Java核心技术卷1_04_对象与类/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/09/Java核心技术卷1_04_对象与类/" class="post-title-link" itemprop="http://yoursite.com/page/6/index.html">04 | 对象与类</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-09 15:01:16" itemprop="dateCreated datePublished" datetime="2019-07-09T15:01:16+08:00">2019-07-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Java/Java核心技术卷1/" itemprop="url" rel="index"><span itemprop="name">Java核心技术卷1</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎对象与对象变量"><a href="#✎对象与对象变量" class="headerlink" title="✎对象与对象变量"></a><center><font color="#36648B">✎</font><br><font color="#36648B">对象与对象变量</font></center></h4><p>下面代码里deadLine变量与birthDay变量引用的是同一个变量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date deadLine = <span class="keyword">new</span> Date();</span><br><span class="line">Date birthDay = deadLine;</span><br></pre></td></tr></table></figure></p>
<h4 id="✎✎GregorianCalendar类"><a href="#✎✎GregorianCalendar类" class="headerlink" title="✎✎GregorianCalendar类"></a><center><font color="#36648B">✎✎</font><br><font color="#36648B">GregorianCalendar类</font></center></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = <span class="keyword">new</span> GregorianCalendar(); <span class="comment">//Calendar是抽象类</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//1.直接设置年月日时分秒</span></span><br><span class="line"><span class="comment">//c.set(2015, Calendar.AUGUST, 2); //2015.08.02</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//2.通过块分别设置相应的年月日时分秒</span></span><br><span class="line"><span class="comment">//注：可以按这种格式继续设置时分秒，如果省略，则按照本地默认设置</span></span><br><span class="line">c.set(Calendar.YEAR, <span class="number">2015</span>); <span class="comment">//2015年</span></span><br><span class="line">c.set(Calendar.MONTH, <span class="number">1</span>); <span class="comment">//2月，0为1月</span></span><br><span class="line">c.set(Calendar.DAY_OF_MONTH, <span class="number">2</span>); <span class="comment">//Calendar.DATE == Calendar.DAY_OF_MONTH</span></span><br><span class="line">                </span><br><span class="line">Date d = c.getTime();</span><br><span class="line">System.out.println(d); <span class="comment">//Mon Feb 02 21:15:13 CST 2015</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//获取相应的年月日时分秒</span></span><br><span class="line">System.out.println(c.get(Calendar.YEAR)); <span class="comment">//2015</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//测试日期计算</span></span><br><span class="line">c.add(Calendar.YEAR, <span class="number">10</span>); <span class="comment">//增加10年,减的话把10变成负的即可</span></span><br><span class="line">System.out.println(c.getTime()); <span class="comment">//Sun Feb 02 21:15:13 CST 2025</span></span><br></pre></td></tr></table></figure>
<p>不要编写如下的返回引用对象的访问器方法，因为容易被外部修改。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Enployee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getHireDay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hireDay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果要返回一个对象的引用，应该首先对它进行克隆。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Enployee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getHireDay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hireDay==<span class="keyword">null</span>?<span class="keyword">null</span>:(Date)hireDay.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Date实现了clone方法。</p>
<h4 id="✎✎✎基于类的访问权限"><a href="#✎✎✎基于类的访问权限" class="headerlink" title="✎✎✎基于类的访问权限"></a><center><font color="#36648B">✎✎✎</font><br><font color="#36648B">基于类的访问权限</font></center></h4><p>一般来说，如果把属性设置为private后，外部在调用的时候是不可以直接通过“点”的方式调用的，但是以下两种例外。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Employee other)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.equals(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为other本来就属于Employee，所以可以在这个类中可以直接调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line"></span><br><span class="line">        System.out.println(employee.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Employee other)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name.equals(other.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为Employee属于Demo的内部类，所以在Demo的方法里可以访问Employee的私有属性。</p>
<h4 id="✎✎✎✎final-实例域"><a href="#✎✎✎✎final-实例域" class="headerlink" title="✎✎✎✎final 实例域"></a><center><font color="#36648B">✎✎✎✎</font><br><font color="#36648B">final 实例域</font></center></h4><p>对象的final属性在构建对象时必须被初始化。</p>
<h4 id="✎✎✎✎✎静态常量"><a href="#✎✎✎✎✎静态常量" class="headerlink" title="✎✎✎✎✎静态常量"></a><center><font color="#36648B">✎✎✎✎✎</font><br><font color="#36648B">静态常量</font></center></h4><p><code>System.out</code>是一个静态常量，如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span></span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream out =  . . . ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>System类里面有有一个setOut方法可以将System.out设置为不同的流，因为setOut是一个本地方法（native），而不是用Java语言实现的。本地方法可以绕过Java语言的存储控制机制，从而对final属性进行修改。自己编写程序时，不应该这样处理。</p>
<h4 id="✎✎✎✎✎✎静态方法"><a href="#✎✎✎✎✎✎静态方法" class="headerlink" title="✎✎✎✎✎✎静态方法"></a><center><font color="#36648B">✎✎✎✎✎✎</font><br><font color="#36648B">静态方法</font></center></h4><p>当对象里有静态方式时，建议使用类名，而不是通过构建的对象来调用静态方法。</p>
<p>可以通过调用方法对属性进行初始化（这种方式有点意思 ），如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = assignId();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">assignId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样写就让assignId相当于一个初始化方法。</p>
<h4 id="✎✎✎✎✎✎✎调用另一个构造器"><a href="#✎✎✎✎✎✎✎调用另一个构造器" class="headerlink" title="✎✎✎✎✎✎✎调用另一个构造器"></a><center><font color="#36648B">✎✎✎✎✎✎✎</font><br><font color="#36648B">调用另一个构造器</font></center></h4><p>如果构造器的第一个语句如this(…)，这个构造器将调用同一个类的另一个构造器,如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="✎✎✎✎✎✎✎✎对象析构与finalize方法"><a href="#✎✎✎✎✎✎✎✎对象析构与finalize方法" class="headerlink" title="✎✎✎✎✎✎✎✎对象析构与finalize方法"></a><center><font color="#36648B">✎✎✎✎✎✎✎✎</font><br><font color="#36648B">对象析构与finalize方法</font></center></h4><p>可以为任何一个类添加finalize方法。finalize方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用这个方法回收任何短缺的资源，因为很难知道这个方法什么时候才能够调用。</p>
<h4 id="✎✎✎✎✎✎✎✎✎类的导入"><a href="#✎✎✎✎✎✎✎✎✎类的导入" class="headerlink" title="✎✎✎✎✎✎✎✎✎类的导入"></a><center><font color="#36648B">✎✎✎✎✎✎✎✎✎</font><br><font color="#36648B">类的导入</font></center></h4><p>只能使用星号<code>*</code>导入一个包，而不能使用<code>Import java.*</code>或者<code>Import java.*.*</code>导入以java为前缀的所有包。</p>
<h4 id="✎✎✎✎✎✎✎✎✎✎包作用域"><a href="#✎✎✎✎✎✎✎✎✎✎包作用域" class="headerlink" title="✎✎✎✎✎✎✎✎✎✎包作用域"></a><center><font color="#36648B">✎✎✎✎✎✎✎✎✎✎</font><br><font color="#36648B">包作用域</font></center></h4><ul>
<li><strong>private</strong> :      只能被定义它们的类访问。</li>
<li><strong>default</strong> :      只能被同一包中的类访问。</li>
<li><strong>protected</strong> : 具有default的权限，并且可以被不同包中所继承的子类访问。</li>
<li><strong>public</strong> ：     可以被任意类访问。</li>
</ul>
<h4 id="✎✎✎✎✎✎✎✎✎✎✎文档注释"><a href="#✎✎✎✎✎✎✎✎✎✎✎文档注释" class="headerlink" title="✎✎✎✎✎✎✎✎✎✎✎文档注释"></a><center><font color="#36648B">✎✎✎✎✎✎✎✎✎✎✎</font><br><font color="#36648B">文档注释</font></center></h4><p>JDK包含一个很有用的工具，叫做javadoc，它可以由源文件生成一个HTML文档。</p>
<p>javadoc从下面几个特性中抽取信息：</p>
<ul>
<li>包</li>
<li>公共类与接口</li>
<li>公有的和受保护的构造器及方法</li>
<li>公有的和受保护的域</li>
</ul>
<h4 id="✎✎✎✎✎✎✎✎✎✎✎✎通用注释"><a href="#✎✎✎✎✎✎✎✎✎✎✎✎通用注释" class="headerlink" title="✎✎✎✎✎✎✎✎✎✎✎✎通用注释"></a><center><font color="#36648B">✎✎✎✎✎✎✎✎✎✎✎✎</font><br><font color="#36648B">通用注释</font></center></h4><ul>
<li><p><code>@author</code>:用在类文档的注释中，表示后作者姓名。可以用多个<code>@author</code>标记。</p>
</li>
<li><p><code>@version</code>:对当前版本的描述。</p>
</li>
<li><p><code>@since</code>:始于什么版本。</p>
</li>
<li><p><code>@deprecated</code>:对类、方法或变量不再使用的标识。</p>
</li>
<li><p><code>@see</code>:链接到某个方法或某个超链接。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将链接到Test类的test(double)方法。</span></span><br><span class="line">@see com.huangjunlong.Test#test(double)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@link</code>:同<code>@see</code>。</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/09/Docker核心技术_08_发布到阿里云/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/09/Docker核心技术_08_发布到阿里云/" class="post-title-link" itemprop="http://yoursite.com/page/6/index.html">08 | 发布到阿里云</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-09 11:35:40" itemprop="dateCreated datePublished" datetime="2019-07-09T11:35:40+08:00">2019-07-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Docker/Docker核心技术/" itemprop="url" rel="index"><span itemprop="name">Docker核心技术</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1、登录</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker login --username=[阿里账号] registry.cn-hangzhou.aliyuncs.com</span><br></pre></td></tr></table></figure></p>
<p><strong>2、命名</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker tag [IMAGE_ID] [REPOSITORY]:[TAG]</span><br></pre></td></tr></table></figure></p>
<p><strong>3、发布</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker push [REPOSITORY]:[TAG]</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/Docker核心技术_07_DockerFile/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/Docker核心技术_07_DockerFile/" class="post-title-link" itemprop="http://yoursite.com/page/6/index.html">07 | DockerFile</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-08 20:14:14" itemprop="dateCreated datePublished" datetime="2019-07-08T20:14:14+08:00">2019-07-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Docker/Docker核心技术/" itemprop="url" rel="index"><span itemprop="name">Docker核心技术</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎DokcerFile构建步骤"><a href="#✎DokcerFile构建步骤" class="headerlink" title="✎DokcerFile构建步骤"></a><center><font color="#36648B">✎</font><br><font color="#36648B">DokcerFile构建步骤</font></center></h4><ul>
<li>编写Dockerfile文件。</li>
<li>docker build。</li>
<li>docker run。</li>
</ul>
<h4 id="✎✎DokcerFile基础知识"><a href="#✎✎DokcerFile基础知识" class="headerlink" title="✎✎DokcerFile基础知识"></a><center><font color="#36648B">✎✎</font><br><font color="#36648B">DokcerFile基础知识</font></center></h4><ul>
<li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数。</li>
<li>指令按照从上到下，顺序执行。</li>
<li>‘#’表示注释。</li>
<li>每条指令都会创建一个新的镜像层，并对镜像进行提交。</li>
</ul>
<h4 id="✎✎✎DockerFile执行流程"><a href="#✎✎✎DockerFile执行流程" class="headerlink" title="✎✎✎DockerFile执行流程"></a><center><font color="#36648B">✎✎✎</font><br><font color="#36648B">DockerFile执行流程</font></center></h4><ul>
<li>docker从基础镜像运行一个容器。</li>
<li>执行一条指令并对容器作出修改。</li>
<li>执行类似docker commit的操作提交一个新的镜像层。</li>
<li>docker再基于刚提交的镜像运行一个新容器。</li>
<li>执行dockerfile中的下一条指令直到所有指令都执行完成。</li>
</ul>
<h4 id="✎✎✎✎DokcerFile保留字指令"><a href="#✎✎✎✎DokcerFile保留字指令" class="headerlink" title="✎✎✎✎DokcerFile保留字指令"></a><center><font color="#36648B">✎✎✎✎</font><br><font color="#36648B">DokcerFile保留字指令</font></center></h4><ul>
<li><strong>FROM</strong>：基础镜像，当前新镜像是基于哪个镜像的。</li>
<li><strong>MAINTAINER</strong>: 镜像维护者的姓名和邮箱地址。</li>
<li><strong>RUN</strong>: 容器构建时需要运行的命令。</li>
<li><strong>EXPOSE</strong>: 当前容器对外暴露出的端口。</li>
<li><strong>WORKDIR</strong>: 指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点。</li>
<li><strong>ENV</strong>: 用来在构建镜像过程中设置环境变量。<blockquote>
<p><strong>问题</strong>：设置的环境变量永久生效吗？</p>
</blockquote>
</li>
<li><strong>ADD</strong>: 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包。</li>
<li><strong>COPY</strong>: 类似ADD，拷贝文件和目录到镜像中。<ul>
<li><code>COPY src dest</code></li>
<li><code>COPY [&quot;src&quot;,&quot;dest&quot;]</code></li>
</ul>
</li>
<li><strong>VOLUME</strong>: 容器数据卷，用于数据保存和持久化工作。</li>
<li><strong>CMD</strong>: 指定一个容器启动时要运行的命令。Dockerfile中可以有多个CMD指令，但只有最后一个生效。CMD会被<code>docker run</code>之后的参数替换。<ul>
<li>shell格式：<code>CMD&lt;命令&gt;</code></li>
<li>exec 格式：<code>CMD[“可执行文件”，“参数1”，“参数2..]</code></li>
<li>参数列表格式：<code>CMD[“参数1”，“参数2”,...]</code>。在指定了<code>ENTRYPOINT</code>指令后，用CMD指定具体的参数。</li>
</ul>
</li>
<li><strong>ENTRYPOINT</strong>: 指定一个容器启动时要运行的命令。ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数，ENTRYPOINT不会被dockerrun之后的参数替换，而是追加这个参数命令。</li>
<li><strong>ONBUILD</strong>: 当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/04/Docker核心技术_06_Docker数据卷容器/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/04/Docker核心技术_06_Docker数据卷容器/" class="post-title-link" itemprop="http://yoursite.com/page/6/index.html">06 | Docker数据卷容器</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-04 11:27:58" itemprop="dateCreated datePublished" datetime="2019-07-04T11:27:58+08:00">2019-07-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Docker/Docker核心技术/" itemprop="url" rel="index"><span itemprop="name">Docker核心技术</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎卷的概念"><a href="#✎卷的概念" class="headerlink" title="✎卷的概念"></a><center><font color="#36648B">✎</font><br><font color="#36648B">卷的概念</font></center></h4><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过UnionFS提供一些用于持续存储或共享数据的特性。<br>卷的设计目的就是<font color="#CD5555">数据的持久化</font>，完全<font color="#CD5555">独立于容器的生存周期</font>，因此Docker不会在容器删除时删除其挂载的数据卷。</p>
<h4 id="✎✎卷的作用"><a href="#✎✎卷的作用" class="headerlink" title="✎✎卷的作用"></a><center><font color="#36648B">✎✎</font><br><font color="#36648B">卷的作用</font></center></h4><ul>
<li>容器的持久化。</li>
<li>容器间继承+共享数据。</li>
<li>容器与主机的数据共享。</li>
</ul>
<h4 id="✎✎✎卷的特点"><a href="#✎✎✎卷的特点" class="headerlink" title="✎✎✎卷的特点"></a><center><font color="#36648B">✎✎✎</font><br><font color="#36648B">卷的特点</font></center></h4><ul>
<li>数据卷可在容器之间共享或重用数据。</li>
<li>卷中的更改可以直接生效。</li>
<li>数据卷中的更改<font color="#CD5555">不会包含在镜像的更新</font>中。</li>
<li>数据卷的生命周期一直持续到<font color="#CD5555">没有容器使用它为止</font>。</li>
</ul>
<h4 id="✎✎✎✎容器内添加数据卷"><a href="#✎✎✎✎容器内添加数据卷" class="headerlink" title="✎✎✎✎容器内添加数据卷"></a><center><font color="#36648B">✎✎✎✎</font><br><font color="#36648B">容器内添加数据卷</font></center></h4><p><strong>1、直接命令添加</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /宿主机绝对路径目录:/容器内目录 IMAGE</span><br></pre></td></tr></table></figure></p>
<p>可以通过<code>inspect</code>命令查看数据卷是否挂载成功。<br>容器关了后，在主机的挂载目录下添加文件A，等容器重启后，容器相应的挂载目录也能看到这个文件A。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run-it-v/宿主机绝对路径目录:/容器内目录:ro IMAGE</span><br></pre></td></tr></table></figure>
<p>上面的命令中(ro = read only,默认是rw)，容器只能对挂载目录进行读，但是主机可以对挂载目录进行读写。</p>
<blockquote>
<p><strong>问题</strong>：如果主机不存在此目录，会自动创建吗？</p>
</blockquote>
<p><strong>2、DockerFile添加</strong><br>可在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME[&quot;/dataVolumeContainer&quot;，&quot;/dataVolumeContainer2&quot;，&quot;/dataVolumeContainer3]</span><br></pre></td></tr></table></figure></p>
<p>该命令创建指定的主机目录是随机目录，无法指定特定目录，具体目录路径可以用<code>inspect</code>命令查看。</p>
<p><strong>3、DockerFile Demo</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">VOLUME[&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;]（这个会在什么时候创建？）</span><br><span class="line">CMD echo &quot;finished,--------success1&quot;（这个会在什么时候打印？）</span><br><span class="line">CMD /bin/bash  （这个有什么用？）</span><br></pre></td></tr></table></figure></p>
<p><strong>4、build构建镜像</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /mydocker/Dockerfile -t  IMAGE .</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>问题</strong>：Docker挂载主机目录Docker访问出现<font color="#CD5555">cannot open directory:Permission denied</font>。<br><br>解决办法：在挂载目录后多加一个<code>-privileged=true</code>参数即可。</p>
</blockquote>
<h4 id="✎✎✎✎✎数据卷容器"><a href="#✎✎✎✎✎数据卷容器" class="headerlink" title="✎✎✎✎✎数据卷容器"></a><center><font color="#36648B">✎✎✎✎✎</font><br><font color="#36648B">数据卷容器</font></center></h4><p>命名的容器挂载数据卷，其它容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为数据卷容器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name dc02 --volumes-from dc01 IMAGE</span><br></pre></td></tr></table></figure>
<p>dc02容器继承dc01容器，同时子容器02的数据也能被01看到。使父容器与子容器的数据共享。</p>
<p><code>--volumes-from</code>不要理解为继承，理解为“联系”会更好一点，而且这种联系是“多向”的。在任何时候，数据卷都是同步的。<br>假设A与B联系，然后C与A联系，那么C与B也会联系。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/04/Docker核心技术_05_Docker镜像/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aFightz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aFightz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/04/Docker核心技术_05_Docker镜像/" class="post-title-link" itemprop="http://yoursite.com/page/6/index.html">05 | Docker镜像</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-04 10:52:23" itemprop="dateCreated datePublished" datetime="2019-07-04T10:52:23+08:00">2019-07-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 16:21:41" itemprop="dateModified" datetime="2020-01-07T16:21:41+08:00">2020-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/Docker/Docker核心技术/" itemprop="url" rel="index"><span itemprop="name">Docker核心技术</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="✎镜像是什么"><a href="#✎镜像是什么" class="headerlink" title="✎镜像是什么"></a><center><font color="#36648B">✎</font><br><font color="#36648B">镜像是什么</font></center></h4><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p>
<h4 id="✎✎UnionFS（联合文件系统）"><a href="#✎✎UnionFS（联合文件系统）" class="headerlink" title="✎✎UnionFS（联合文件系统）"></a><center><font color="#36648B">✎✎</font><br><font color="#36648B">UnionFS（联合文件系统）</font></center></h4><p>Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p><font color="#CD5555">特性：</font>一次同时加载多个文件系统，从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<h4 id="✎✎✎Docker镜像加载原理"><a href="#✎✎✎Docker镜像加载原理" class="headerlink" title="✎✎✎Docker镜像加载原理"></a><center><font color="#36648B">✎✎✎</font><br><font color="#36648B">Docker镜像加载原理</font></center></h4><p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs，这一层与我们典型的Linux/Unix系统是一样的：包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。<br>rootfs（root file system），在bootfs之上。包含的就是典型Linux系统中的/dev，/proc，/bin，/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。<br>重点说是就是<font color="#CD5555">内核共用</font>。</p>
<h4 id="✎✎✎✎镜像的分层"><a href="#✎✎✎✎镜像的分层" class="headerlink" title="✎✎✎✎镜像的分层"></a><center><font color="#36648B">✎✎✎✎</font><br><font color="#36648B">镜像的分层</font></center></h4><p>分层的优点：<br>最大的一个好处就是<font color="#CD5555">共享资源</font>。<br>比如：有多个镜像都从相同的base镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，同时内存中也只需加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
<h4 id="✎✎✎✎✎特点"><a href="#✎✎✎✎✎特点" class="headerlink" title="✎✎✎✎✎特点"></a><center><font color="#36648B">✎✎✎✎✎</font><br><font color="#36648B">特点</font></center></h4><ul>
<li>Docker镜像都是<font color="#CD5555">只读的</font>。</li>
<li>当容器启动时，一个新的<font color="#CD5555">可写层</font>被加载到镜像的顶部，这一层通常被称作<font color="#CD5555">“容器层”</font>，容器层”之下的都叫<font color="#CD5555">“镜像层”</font>。</li>
</ul>
<h4 id="✎✎✎✎✎✎镜像Commit"><a href="#✎✎✎✎✎✎镜像Commit" class="headerlink" title="✎✎✎✎✎✎镜像Commit"></a><center><font color="#36648B">✎✎✎✎✎✎</font><br><font color="#36648B">镜像Commit</font></center></h4><p>提交容器副本使之成为一个<font color="#CD5555">新的镜像</font>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器lD 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">aFightz</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">98</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">35</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aFightz</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  


  
  

  

  

  

  

  

  

</body>
</html>
